<!DOCTYPE html><html><head><title>R: Read Data Values</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body> <div style='padding: 20pt; border: 2px solid black; text-align:center;'><b>This help topic is for R version 1.5.0. For the corresponding topic in the current version of R, see <a href='https://stat.ethz.ch/R-manual/R-patched/library/base/html/scan.html'>https://stat.ethz.ch/R-manual/R-patched/library/base/html/scan.html</a></b></div><div class="container">

<table style="width: 100%;"><tr><td>scan {base}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2 id='scan'>Read Data Values</h2>

<h3>Description</h3>

<p>Read data into a vector or list from the console or file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scan(file = "", what = double(0), nmax = -1, n = -1, sep = "",
     quote = if (sep=="\n") "" else "'\"", dec = ".",
     skip = 0, nlines = 0, na.strings = "NA",
     flush = FALSE, fill = FALSE, strip.white = FALSE, quiet = FALSE,
     blank.lines.skip = TRUE, multi.line = TRUE, comment.char = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scan_:_file">file</code></td>
<td>
<p>the name of a file to read data values from.  If the
specified file is <code>""</code>, then input is taken from the keyboard
(in this case input can be terminated by a blank line).
</p>
<p>Otherwise, the file name is interpreted <em>relative</em> to the
current working directory (given by <code>getwd()</code>),
unless it specifies an <em>absolute</em> path.
Tilde-expansion is performed where supported.
</p>
<p>Alternatively, <code>file</code> can be a <code>connection</code>, which
will be opened if necessary, and if so closed at the end of the
function call.
</p>
<p><code>file</code> can also be a complete URL.
</p>
</td></tr>
<tr><td><code id="scan_:_what">what</code></td>
<td>
<p>the type of <code>what</code> gives the type of data to be
read.  If <code>what</code> is a list, it is assumed that the lines of the
data file are records each containing <code>length(what)</code> items
(&ldquo;fields&rdquo;).</p>
</td></tr>
<tr><td><code id="scan_:_nmax">nmax</code></td>
<td>
<p>the maximum number of data values to be read, or if
<code>what</code> is a list, the maximum number of records to be read.  If
omitted (and <code>nlines</code> is not set to a positive value),
<code>scan</code> will read to the end of <code>file</code>.</p>
</td></tr>
<tr><td><code id="scan_:_n">n</code></td>
<td>
<p>the maximum number of data values to be read, defaulting to
no limit.</p>
</td></tr>
<tr><td><code id="scan_:_sep">sep</code></td>
<td>
<p>by default, scan expects to read white-space delimited
input fields.  Alternatively, <code>sep</code> can be used to specify a
character which delimits fields.  A field is always delimited by a
newline unless it is quoted.</p>
</td></tr> 
<tr><td><code id="scan_:_quote">quote</code></td>
<td>
<p>the set of quoting characters as a single character
string.</p>
</td></tr>
<tr><td><code id="scan_:_dec">dec</code></td>
<td>
<p>decimal point character.</p>
</td></tr>
<tr><td><code id="scan_:_skip">skip</code></td>
<td>
<p>the number of  lines of the input file to skip before
beginning to read data values.</p>
</td></tr>
<tr><td><code id="scan_:_nlines">nlines</code></td>
<td>
<p>the maximum number of lines of data to be read.</p>
</td></tr>
<tr><td><code id="scan_:_na.strings">na.strings</code></td>
<td>
<p>character vector.  Elements of this vector are to be
interpeted as missing (<code>NA</code>) values.</p>
</td></tr>
<tr><td><code id="scan_:_flush">flush</code></td>
<td>
<p>logical: if <code>TRUE</code>, <code>scan</code> will flush to the
end of the line after reading the last of the fields requested.
This allows putting comments after the last field, but precludes
putting more that one record on a line.</p>
</td></tr>
<tr><td><code id="scan_:_fill">fill</code></td>
<td>
<p>logical: if <code>TRUE</code>, <code>scan</code> will implicitly add
empty fields to any lines with fewer fields than implied by
<code>what</code>.</p>
</td></tr>
<tr><td><code id="scan_:_strip.white">strip.white</code></td>
<td>
<p>vector of logical value(s) corresponding to items
in the <code>what</code> argument. It is used only when <code>sep</code> has
been specified, and allows the stripping of leading and trailing
white space from <code>character</code> fields (<code>numeric</code> fields
are always stripped).
</p>
<p>If <code>strip.white</code> is of length 1, it applies to all fields;
otherwise, if <code>strip.white[i]</code> is <code>TRUE</code> <em>and</em> the
<code>i</code>-th field is of mode character (because <code>what[i]</code> is)
then the leading and trailing white space from field <code>i</code> is
stripped.</p>
</td></tr>
<tr><td><code id="scan_:_quiet">quiet</code></td>
<td>
<p>logical: if <code>FALSE</code> (default), scan() will print a
line, saying how many items have been read.</p>
</td></tr>
<tr><td><code id="scan_:_blank.lines.skip">blank.lines.skip</code></td>
<td>
<p>logical: if <code>TRUE</code> blank lines in the
input are ignored, except when counting <code>skip</code> and <code>nlines</code>.</p>
</td></tr>
<tr><td><code id="scan_:_multi.line">multi.line</code></td>
<td>
<p>logical. Only used if <code>what</code> is a list.
If <code>FALSE</code>, all of a record must appear on one line (but more
than one record can appear on a single line).  Note that using
<code>fill = TRUE</code> implies that a record will terminated at the end
of a line.</p>
</td></tr>
<tr><td><code id="scan_:_comment.char">comment.char</code></td>
<td>
<p>character: a character vector of length one
containing a single character or an empty string.  Use <code>""</code> to
turn off the interpretation of comments altogether (the default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The value of <code>what</code> can be a list of types, in which case
<code>scan</code> returns a list of vectors with the types given by the
types of the elements in <code>what</code>.  This provides a way of reading
columnar data.  If any of the type is <code>NULL</code>, the corresponding
field is skipped (but a <code>NULL</code> component appears in the result).
</p>
<p>Empty numeric fields are always regarded as missing values.
Empty character fields are scanned as empty character vectors, unless
<code>na.strings</code> contains <code>""</code> when they are regarded as missing
values.
</p>
<p>If <code>sep</code> is the default (<code>""</code>), the character <code>\</code>
in a quoted string escapes the following character, so quotes may
included in the string by escaping them.
</p>
<p>If <code>sep</code> is non-default, the fields may be quoted in the style of
&lsquo;<span class="file">.csv</span>&rsquo; files where separators inside quotes (<code>''</code> or 
<code>""</code>) are ignored and quotes may be put inside strings by
doubling them.  However, if <code>sep = "\n"</code> it is assumed
by default that one wants to read entire lines verbatim.
</p>
<p>Note that since <code>sep</code> is a separator and not a terminator,
reading a file by <code>scan("foo", sep="\n", blank.lines.skip=FALSE)</code>
will give an empty file line if the file ends in a linefeed and not it
it does not.  This might not be what you expected; see also
<code>readLines</code>.
</p>
<p>If <code>comment.char</code> occurs (except inside a quoted character
field), it signals that the rest of the line
should be regarded as a comment and be discarded.  Lines beginning
with a comment character (possibly after white space) are treated
as blank lines. 
</p>


<h3>Value</h3>

<p>if <code>what</code> is a list, a list of the same length and same names (as
any) as <code>what</code>.
</p>
<p>Otherwise, a vector of the type of <code>what</code>.
</p>


<h3>Note</h3>

<p>The default for <code>multi.line</code> differs from S.  To read one record
per line, use <code>flush = TRUE</code> and <code>multi.line = FALSE</code>.
</p>
<p>If number of items is not specified, the internal
mechanism re-allocates memory in powers of two and so could use up
to three times as much memory as needed.  (It needs both old and new
copies.)  If you can, specify either <code>n</code> or <code>nmax</code> whenever
inputting a large vector, and <code>nmax</code> or <code>nlines</code> when
inputting a large list.
</p>


<h3>See Also</h3>

<p><code>read.table</code> for more user-friendly reading of data
matrices;
<code>readLines</code> to read a file a line at a time.
<code>write</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cat("TITLE extra line", "2 3 5 7", "11 13 17", file="ex.data", sep="\n")
pp &lt;- scan("ex.data", skip = 1, quiet= TRUE)
    scan("ex.data", skip = 1)
    scan("ex.data", skip = 1, nlines=1)# only 1 line after the skipped one
str(scan("ex.data", what = list("","",""))) # flush is F -&gt; read "7"
str(scan("ex.data", what = list("","",""), flush = TRUE))
unlink("ex.data") # tidy up
</code></pre>

<hr /><div style="text-align: center;">[Package <em>base</em> version 1.5.0 ]</div>
</div>
</body></html>
