<!DOCTYPE html><html><head><title>R: Loading and Listing of Packages</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body> <div style='padding: 20pt; border: 2px solid black; text-align:center;'><b>This help topic is for R version 1.9.0. For the current version of R, try <a href='https://stat.ethz.ch/R-manual/R-patched/library/base/html/library.html'>https://stat.ethz.ch/R-manual/R-patched/library/base/html/library.html</a></b></div><div class="container"><main>

<table style="width: 100%;"><tr><td>library {base}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Loading and Listing of Packages</h2>

<h3>Description</h3>

<p><code>library</code> and <code>require</code> load add-on packages.
</p>
<p><code>.First.lib</code> is called when a package is loaded;
<code>.Last.lib</code> is called when a package is detached.
</p>
<p><code>.packages</code> returns information about package availability.
</p>
<p><code>.path.package</code> returns information about where a package was
loaded from.
</p>
<p><code>.find.package</code> returns the directory paths of installed
packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>library(package, help, pos = 2, lib.loc = NULL, character.only = FALSE,
        logical.return = FALSE, warn.conflicts = TRUE,
        keep.source = getOption("keep.source.pkgs"),
        verbose = getOption("verbose"), version)
require(package, quietly = FALSE, warn.conflicts = TRUE,
        keep.source = getOption("keep.source.pkgs"),
        character.only = FALSE, version, save = TRUE)

.First.lib(libname, pkgname)
.Last.lib(libpath)

.packages(all.available = FALSE, lib.loc = NULL)
.path.package(package = .packages(), quiet = FALSE)
.find.package(package, lib.loc = NULL, quiet = FALSE,
              verbose = getOption("verbose"))
.libPaths(new)

.Library
.Autoloaded
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="package">package</code>, <code id="help">help</code></td>
<td>
<p>the name of a package, given as a name or
literal character string, or a character string, depending on
whether <code>character.only</code> is <code>FALSE</code> (default) or
<code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="pos">pos</code></td>
<td>
<p>the position on the search list at which to attach the
loaded package.  Note that <code>.First.lib</code> may attach other
packages, and <code>pos</code> is computed <em>after</em> <code>.First.lib</code>
has been run.  Can also be the name of a position on the current
search list as given by <code>search()</code>.</p>
</td></tr>
<tr><td><code id="lib.loc">lib.loc</code></td>
<td>
<p>a character vector describing the location of <span class="rlang"><b>R</b></span>
library trees to search through, or <code>NULL</code>.  The default value
of <code>NULL</code> corresponds to all libraries currently known.</p>
</td></tr>
<tr><td><code id="character.only">character.only</code></td>
<td>
<p>a logical indicating whether <code>package</code> or
<code>help</code> can be assumed to be character strings.</p>
</td></tr>
<tr><td><code id="version">version</code></td>
<td>
<p>A character string denoting a version number of the
package to be loaded.  If no version is given, a suitable default
is chosen.</p>
</td></tr>
<tr><td><code id="logical.return">logical.return</code></td>
<td>
<p>logical.  If it is <code>TRUE</code>,  <code>FALSE</code> or
<code>TRUE</code> is returned to indicate success.</p>
</td></tr>
<tr><td><code id="warn.conflicts">warn.conflicts</code></td>
<td>
<p>logical.  If <code>TRUE</code>, warnings are
printed about <code>conflicts</code> from attaching the new
package, unless that package contains an object <code>.conflicts.OK</code>.</p>
</td></tr>
<tr><td><code id="keep.source">keep.source</code></td>
<td>
<p>logical.  If <code>TRUE</code>, functions &ldquo;keep their
source&rdquo; including comments, see argument <code>keep.source</code> to
<code>options</code>.</p>
</td></tr>
<tr><td><code id="verbose">verbose</code></td>
<td>
<p>a logical.  If <code>TRUE</code>, additional diagnostics are
printed.</p>
</td></tr>
<tr><td><code id="quietly">quietly</code></td>
<td>
<p>a logical.  If <code>TRUE</code>, no message confirming
package loading is printed.</p>
</td></tr>
<tr><td><code id="save">save</code></td>
<td>
<p>logical or environment.  If <code>TRUE</code>, a call to
<code>require</code> from the source for a package will save the name of
the required package in the variable <code>".required"</code>, allowing
function <code>detach</code> to warn if a required package is
detached. See section &lsquo;Packages that require other packages&rsquo; below.</p>
</td></tr>
<tr><td><code id="libname">libname</code></td>
<td>
<p>a character string giving the library directory where
the package was found.</p>
</td></tr>
<tr><td><code id="pkgname">pkgname</code></td>
<td>
<p>a character string giving the name of the package.</p>
</td></tr>
<tr><td><code id="libpath">libpath</code></td>
<td>
<p>a character string giving the complete path to the
package.</p>
</td></tr>
<tr><td><code id="all.available">all.available</code></td>
<td>
<p>logical; if <code>TRUE</code> return a character vector
of all available packages in <code>lib.loc</code>.</p>
</td></tr>
<tr><td><code id="quiet">quiet</code></td>
<td>
<p>logical.
For <code>.path.package</code>, should this not give warnings or an error
if the package(s) are not loaded?
For <code>.find.package</code>, should this not give warnings or an error
if the package(s) are not found?</p>
</td></tr>
<tr><td><code id="new">new</code></td>
<td>
<p>a character vector with the locations of <span class="rlang"><b>R</b></span> library trees.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>library(package)</code> and <code>require(package)</code> both load the
package with name <code>package</code>.  <code>require</code> is designed for use
inside other functions; it returns <code>FALSE</code> and gives a warning
(rather than an error as <code>library()</code> does) if the package does
not exist.  Both functions check and update the list of currently
loaded packages and do not reload code that is already loaded.
</p>
<p>For large packages, setting <code>keep.source = FALSE</code> may save quite
a bit of memory.
</p>
<p>If <code>library</code> is called with no <code>package</code> or <code>help</code>
argument, it lists all available packages in the libraries specified
by <code>lib.loc</code>, and returns the corresponding information in an
object of class <code>"libraryIQR"</code>.  The structure of this class may
change in future versions.  In earlier versions of R, only the names
of all available packages were returned; use <code>.packages(all =
    TRUE)</code> for obtaining these.  Note that
<code>installed.packages()</code> returns even more information.
</p>
<p><code>library(help = somename)</code> computes basic information about the
package <code>somename</code>, and returns this in an object of class
<code>"packageInfo"</code>.  The structure of this class may change in
future versions.  When used with the default value (<code>NULL</code>) for
<code>lib.loc</code>, the loaded packages are searched before the libraries.
</p>
<p><code>.First.lib</code> is called when a package is loaded by
<code>library</code>.  It is called with two arguments, the name of the
library directory where the package was found (i.e., the corresponding
element of <code>lib.loc</code>), and the name of the package (in that
order).  It is a good place to put calls to <code>library.dynam</code>
which are needed when loading a package into this function (don't call
<code>library.dynam</code> directly, as this will not work if the package
is not installed in a &ldquo;standard&rdquo; location).  <code>.First.lib</code>
is invoked after the search path interrogated by <code>search()</code>
has been updated, so
<code>as.environment(match("package:name", search()))</code> will return the
environment in which the package is stored.  If calling
<code>.First.lib</code> gives an error the loading of the package is
abandoned, and the package will be unavailable.  Similarly, if the
option <code>".First.lib"</code> has a list element with the package's name,
this element is called in the same manner as <code>.First.lib</code> when
the package is loaded.  This mechanism allows the user to set package
&ldquo;load hooks&rdquo; in addition to startup code as provided by the package
maintainers.
</p>
<p><code>.Last.lib</code> is called when a package is detached.  Beware
that it might be called if <code>.First.lib</code> has failed, so it
should be written defensively. (It is called within <code>try</code>,
so errors will not stop the package being detached.)
</p>
<p><code>.packages()</code> returns the &ldquo;base names&rdquo; of the currently
attached packages <em>invisibly</em> whereas
<code>.packages(all.available = TRUE)</code> gives (visibly) <em>all</em>
packages available in the library location path <code>lib.loc</code>.
</p>
<p><code>.path.package</code> returns the paths from which the named packages
were loaded, or if none were named, for all currently loaded packages.
Unless <code>quiet = TRUE</code> it will warn if some of the packages named
are not loaded, and given an error if none are.  This function is not
meant to be called by users, and its interface might change in future
versions.
</p>
<p><code>.find.package</code> returns the paths to the locations where the
given packages can be found.  If <code>lib.loc</code> is <code>NULL</code>, then
then attached packages are searched before the libraries.  If a
package is found more than once, the first match is used.  Unless
<code>quiet = TRUE</code> a warning will be given about the named packages
which are not found, and an error if none are.  If <code>verbose</code> is
true, warnings about packages found more than once are given.  This
function is not meant to be called by users, and its interface might
change in future versions.
</p>
<p><code>.Autoloaded</code> contains the &ldquo;base names&rdquo; of the packages for
which autoloading has been promised.
</p>
<p><code>.Library</code> is a character string giving the location of the
default library, the &lsquo;<span class="file">library</span>&rsquo; subdirectory of <span class="env">R\_HOME</span>.
<code>.libPaths</code> is used for getting or setting the library trees that
<span class="rlang"><b>R</b></span> knows about (and hence uses when looking for packages).  If called
with argument <code>new</code>, the library search path is set to
the existing files in <code>unique(new, .Library)</code> and this is
returned.  If given no argument, a character vector with the currently
known library trees is returned.
</p>
<p>The library search path is initialized at startup from the environment
variable <span class="env">R\_LIBS</span> (which should be a colon-separated list of
directories at which <span class="rlang"><b>R</b></span> library trees are rooted) by calling
<code>.libPaths</code> with the directories specified in <span class="env">R\_LIBS</span>.
</p>


<h3>Value</h3>

<p><code>library</code> returns the list of loaded (or available) packages
(or <code>TRUE</code> if <code>logical.return</code> is <code>TRUE</code>).
<code>require</code> returns a logical indicating whether the required
package is available.
</p>


<h3>Packages that require other packages</h3>

<p>The source code for a
package that requires one or more other packages should have a call
to <code>require</code>, preferably near the beginning of the source, and
of course before any code that uses functions, classes or methods
from the other package.  The default for argument <code>save</code> will
save the names of all required packages in the environment of the
new package.  The saved package names are used by
<code>detach</code> when a package is detached to warn if other
packages still require the detached package.  Also, if a package is
installed with saved image (see INSTALL), the saved package
names are used to require these packages when the new package is attached.</p>


<h3>Formal methods</h3>

<p><code>library</code> takes some further actions when package <span class="pkg">methods</span>
is attached (as it is by default).  Packages may define formal generic
functions as well as re-defining functions in other packages (notably
<span class="pkg">base</span>) to be generic, and this information is cached whenever
such a package is loaded after <span class="pkg">methods</span> and re-defined functions
are excluded from the list of conflicts.  The check requires looking
for a pattern of objects; the pattern search may be avoided by
defining an object <code>.noGenerics</code>
(with any value) in the package.  Naturally, if the package
<em>does</em> have any such methods, this will prevent them from being used.
</p>


<h3>Note</h3>

<p><code>library</code> and <code>require</code> can only load an <em>installed</em>
package, and this is detected by having a &lsquo;<span class="file">DESCRIPTION</span>&rsquo; file
containing a <code>Built:</code> field.  Packages
installed prior to 1.2.0 (released in December 2000) will need to be
re-installed.
</p>
<p>Under Unix-alikes, the code checks that the package was installed
under a similar operating system as given by <code>R.version$platform</code>
(the canonical name of the platform under which R was compiled),
provided it contains compiled code.  Packages which do not contain
compiled code can be shared between Unix-alikes, but not to other OSes
because of potential problems with line endings and OS-specific help
files.
</p>
<p><code>library</code> and <code>require</code> use the underlying file system
services to locate the libraries, with the result that on
case-sensitive file systems package names are case-sensitive
(i.e., <code>library(foo)</code> is different from
<code>library(Foo)</code>), but they are not distinguished on
case-insensitive file systems such as MS Windows.  A warning
is issued if the user specifies a name which isn't a perfect match
to the package name, because future versions of <span class="rlang"><b>R</b></span> will require
exact matches.
</p>


<h3>Author(s)</h3>

<p>R core;
Guido Masarotto for the <code>all.available=TRUE</code> part of
<code>.packages</code>.
</p>


<h3>References</h3>

<p>Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988)
<em>The New S Language</em>.
Wadsworth \&amp; Brooks/Cole.
</p>


<h3>See Also</h3>

<p><code>attach</code>, <code>detach</code>, <code>search</code>,
<code>objects</code>, <code>autoload</code>,
<code>library.dynam</code>, <code>data</code>,
<code>install.packages</code> and
<code>installed.packages</code>;
<code>INSTALL</code>, <code>REMOVE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(.packages())               # maybe just "base"
.packages(all = TRUE)       # return all available as character vector
library()                   # list all available packages
library(lib = .Library)     # list all packages in the default library
library(help = eda)         # documentation on package 'eda'
library(eda)                # load package 'eda'
require(eda)                # the same
(.packages())               # "eda", too
detach("package:eda")

# if the package name is in a character vector, use
pkg &lt;- "eda"
library(pkg, character.only = TRUE)
detach(pos = match(paste("package", pkg, sep=":"), search()))

require(pkg, character.only = TRUE)
detach(pos = match(paste("package", pkg, sep=":"), search()))

.path.package()
.Autoloaded                 # maybe "ctest"

.libPaths()                 # all library trees R knows about

require(nonexistent)        # FALSE
## Not run: 
## Suppose a package needs to call a shared library named 'fooEXT',
## where 'EXT' is the system-specific extension.  Then you should use
.First.lib &lt;- function(lib, pkg) {
  library.dynam("foo", pkg, lib)
}

## if you want to mask as little as possible, use
library(mypkg, pos = "package:base")

## End(Not run)</code></pre>

<hr /><div style="text-align: center;">[<a href='/r-help/1.9.0/00index.html'>Package <em>base</em> version 1.9.0</a> ]</div></main>

</div>
</body></html>
