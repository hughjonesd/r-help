<!DOCTYPE html><html><head><title>R: Numeric Constants</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body> <div style='padding: 20pt; border: 2px solid black; text-align:center;'><b>This help topic is for R version 3.2.1. For the corresponding topic in the current version of R, see <a href='https://stat.ethz.ch/R-manual/R-patched/library/base/html/NumericConstants.html'>https://stat.ethz.ch/R-manual/R-patched/library/base/html/NumericConstants.html</a></b></div><div class="container">

<table style="width: 100%;"><tr><td>NumericConstants {base}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2 id='NumericConstants'>Numeric Constants</h2>

<h3>Description</h3>

<p>How <span class="rlang"><b>R</b></span> parses numeric constants.
</p>


<h3>Details</h3>

<p><span class="rlang"><b>R</b></span> parses numeric constants in its input in a very similar way to C99
floating-point constants.
</p>
<p><code>Inf</code> and <code>NaN</code> are numeric constants (with
<code>typeof(.) "double"</code>).  In text input (e.g., in
<code>scan</code> and <code>as.double</code>), these are recognized
ignoring case as is <code>infinity</code> as an alternative to <code>Inf</code>.
<code>NA_real_</code> and <code>NA_integer_</code> are constants of
types <code>"double"</code> and <code>"integer"</code> representing missing
values.  All other numeric constants start with a digit or period and
are either a decimal or hexadecimal constant optionally followed by
<code>L</code>.
</p>
<p>Hexadecimal constants start with <code>0x</code> or <code>0X</code> followed by
a nonempty sequence from <code>0-9 a-f A-F .</code> which is interpreted as a
hexadecimal number, optionally followed by a binary exponent.  A binary
exponent consists of a <code>P</code> or <code>p</code> followed by an optional
plus or minus sign followed by a non-empty sequence of (decimal)
digits, and indicates multiplication by a power of two.  Thus
<code>0x123p456</code> is <code class="reqn">291 \times 2^{456}</code>.
</p>
<p>Decimal constants consist of a nonempty sequence of digits possibly
containing a period (the decimal point), optionally followed by a
decimal exponent.  A decimal exponent consists of an <code>E</code> or
<code>e</code> followed by an optional plus or minus sign followed by a
non-empty sequence of digits, and indicates multiplication by a power
of ten.
</p>
<p>Values which are too large or too small to be representable will
overflow to <code>Inf</code> or underflow to <code>0.0</code>.
</p>
<p>A numeric constant immediately followed by <code>i</code> is regarded as an
imaginary complex number.
</p>
<p>An numeric constant immediately followed by <code>L</code> is regarded as an
<code>integer</code> number when possible (and with a warning if it
contains a <code>"."</code>).
</p>
<p>Only the ASCII digits 0&ndash;9 are recognized as digits, even in languages
which have other representations of digits.  The &lsquo;decimal
separator&rsquo; is always a period and never a comma.
</p>
<p>Note that a leading plus or minus is not regarded by the parser as
part of a numeric constant but as a unary operator applied to the constant.
</p>


<h3>Note</h3>

<p>When a string is parsed to input a numeric constant, the number may or
may not be representable exactly in the C double type used.  If not
one of the nearest representable numbers will be returned.
</p>
<p><span class="rlang"><b>R</b></span>'s own C code is used to convert constants to binary numbers, so the
effect can be expected to be the same on all platforms implementing
full IEC 600559 arithmetic (the most likely area of difference being
the handling of numbers less than <code>.Machine$double.xmin</code>).
The same code is used by <code>scan</code>.
</p>


<h3>See Also</h3>

<p><code>Syntax</code>.
For complex numbers, see <code>complex</code>.
<code>Quotes</code> for the parsing of character constants,
<code>Reserved</code> for the &ldquo;reserved words&rdquo; in <span class="rlang"><b>R</b></span>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## You can create numbers using fixed or scientific formatting.
2.1
2.1e10
-2.1E-10

## The resulting objects have class numeric and type double.
class(2.1)
typeof(2.1)

## This holds even if what you typed looked like an integer.
class(2)
typeof(2)

## If you actually wanted integers, use an "L" suffix.
class(2L)
typeof(2L)

## These are equal but not identical
2 == 2L
identical(2, 2L)

## You can write numbers between 0 and 1 without a leading "0"
## (but typically this makes code harder to read)
.1234

sqrt(1i) # remember elementary math?
utils::str(0xA0)
identical(1L, as.integer(1))

## You can combine the "0x" prefix with the "L" suffix :
identical(0xFL, as.integer(15))
</code></pre>

<hr /><div style="text-align: center;">[Package <em>base</em> version 3.2.1 ]</div>
</div>
</body></html>
