<!DOCTYPE html><html><head><title>R: Numeric Constants</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body> <div style='padding: 20pt; border: 2px solid black; text-align:center;'><b>This help topic is for R version 2.15.0. For the corresponding topic in the current version of R, see <a href='https://stat.ethz.ch/R-manual/R-patched/library/base/html/NumericConstants.html'>https://stat.ethz.ch/R-manual/R-patched/library/base/html/NumericConstants.html</a></b></div><div class="container">

<table style="width: 100%;"><tr><td>NumericConstants {base}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2 id='NumericConstants'>Numeric Constants</h2>

<h3>Description</h3>

<p>How <span class="rlang"><b>R</b></span> parses numeric constants.
</p>


<h3>Details</h3>

<p><span class="rlang"><b>R</b></span> parses numeric constants in its input in a very similar way to C99
floating-point constants.
</p>
<p><code>Inf</code> and <code>NaN</code> are numeric constants (with
<code>typeof(.) "double"</code>).  These are recognized ignoring case,
as is <code>infinity</code> as an alternative to <code>Inf</code>.
<code>NA_real_</code> and <code>NA_integer_</code> are constants of
types <code>"double"</code> and <code>"integer"</code> representing missing
values.  All other numeric constants start with a digit or period and
are either a decimal or hexadecimal constant optionally followed by
<code>L</code>.
</p>
<p>Hexadecimal constants start with <code>0x</code> or <code>0X</code> followed by
a nonempty sequence from <code>0-9 a-f A-F .</code> which is interpreted as a
hexadecimal number, optionally followed by a binary exponent.  A binary
exponent consists of a <code>P</code> or <code>p</code> followed by an optional
plus or minus sign followed by a non-empty sequence of (decimal)
digits, and indicates multiplication by a power of two.  Thus
<code>0x123p456</code> is <code class="reqn">291 \times 2^{456}</code>.
</p>
<p>Decimal constants consist of a nonempty sequence of digits possibly
containing a period (the decimal point), optionally followed by a
decimal exponent.  A decimal exponent consists of an <code>E</code> or
<code>e</code> followed by an optional plus or minus sign followed by a
non-empty sequence of digits, and indicates multiplication by a power
of ten.
</p>
<p>Values which are too large or too small to be representable will
overflow to <code>Inf</code> or underflow to <code>0.0</code>.
</p>
<p>A numeric constant immediately followed by <code>i</code> is regarded as an
imaginary complex number.
</p>
<p>An numeric constant immediately followed by <code>L</code> is regarded as an
<code>integer</code> number when possible (and with a warning if it
contains a <code>"."</code>).
</p>
<p>Only the ASCII digits 0&ndash;9 are recognized as digits, even in languages
which have other representations of digits.  The &lsquo;decimal
separator&rsquo; is always a period and never a comma.
</p>
<p>Note that a leading plus or minus is not regarded by the parser as
part of a numeric constant but as a unary operator applied to the constant.
</p>


<h3>Note</h3>

<p>When a string is parsed to input a numeric constant, the number may or
may not be representable exactly in the C double type used.  If not
one of the nearest representable numbers will be returned.
</p>
<p><span class="rlang"><b>R</b></span>'s own C code is used to convert constants to binary numbers, so the
effect can be expected to be the same on all platforms implementing
full IEC 600559 arithmetic (the most likely area of difference being
the handling of numbers less than <code>.Machine$double.xmin</code>).
The same code is used by <code>scan</code>.  </p>


<h3>See Also</h3>

<p><code>Syntax</code>.
</p>
<p><code>Quotes</code> for the parsing of character constants,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>2.1
typeof(2)
sqrt(1i) # remember elementary math?
utils::str(0xA0)
identical(1L, as.integer(1))

## You can combine the "0x" prefix with the "L" suffix :
identical(0xFL, as.integer(15))
</code></pre>

<hr /><div style="text-align: center;">[<a href='/r-help/2.15.0/00index.html'>Package <em>base</em> version 2.15.0</a> ]</div>
</div>
</body></html>
