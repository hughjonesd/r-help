<!DOCTYPE html><html><head><title>R: Hershey Vector Fonts in R</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body> <div style='padding: 20pt; border: 2px solid black; text-align:center;'><b>This help topic is for R version 1.0. For the corresponding topic in the current version of R, see <a href='https://stat.ethz.ch/R-manual/R-patched/library/base/html/Hershey.html'>https://stat.ethz.ch/R-manual/R-patched/library/base/html/Hershey.html</a></b></div><div class="container">

<table style="width: 100%;"><tr><td>Hershey {base}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2 id='Hershey'>Hershey Vector Fonts in R</h2>

<h3>Description</h3>

<p>If the <code>vfont</code> argument to one of the text-drawing functions
(<code>text</code> and <code>contour</code>) 
is a character vector of length 2, hershey vector fonts are used to
render the text.
</p>
<p>These fonts have two advantages:  
</p>

<ol>
<li><p> vector fonts describe each
character in terms of a set of points;  <span class="rlang"><b>R</b></span> renders the character by 
joining up the points with straight lines.  This intimate knowledge of
the outline of each character means that <span class="rlang"><b>R</b></span> can arbitrarily transform
the characters, which can mean that the vector fonts look better
for rotated and 3d text.
</p>
</li>
<li><p> this implementation was adapted from the GNU libplot library
which provides support for non-ASCII and non-English fonts.  This means
that it is possible, for example, to produce wierd plotting symbols and
Japanese characters.
</p>
</li></ol>



<h3>Details</h3>

<p>The Hershey characters are organised into a set of fonts, which are 
specified by a typeface (e.g., <code>serif</code> or <code>sans serif</code>) 
and a fontindex
(e.g., <code>plain</code> or <code>italic</code>).
The first element of <code>vfont</code> specifies the typeface and the second 
element specifies the fontindex.  The first table
produced by <code>example(Hershey)</code> shows the character <code>a</code> produced
by each of the different fonts. 
</p>
<p>The available values for <code>(typeface, fontindex)</code> for Hershey
vector fonts are:
</p>

<table>
<tr>
 <td style="text-align: left;">
    serif </td><td style="text-align: left;"> plain </td>
</tr>
<tr>
 <td style="text-align: left;">
    serif </td><td style="text-align: left;"> italic </td>
</tr>
<tr>
 <td style="text-align: left;">
    serif </td><td style="text-align: left;"> bold </td>
</tr>
<tr>
 <td style="text-align: left;">
    serif </td><td style="text-align: left;"> bold italic </td>
</tr>
<tr>
 <td style="text-align: left;">
    serif </td><td style="text-align: left;"> cyrillic </td>
</tr>
<tr>
 <td style="text-align: left;">
    serif </td><td style="text-align: left;"> oblique cyrillic </td>
</tr>
<tr>
 <td style="text-align: left;">
    serif </td><td style="text-align: left;"> EUC </td>
</tr>
<tr>
 <td style="text-align: left;">
    sans serif </td><td style="text-align: left;"> plain </td>
</tr>
<tr>
 <td style="text-align: left;">
    sans serif </td><td style="text-align: left;"> italic </td>
</tr>
<tr>
 <td style="text-align: left;">
    sans serif </td><td style="text-align: left;"> bold </td>
</tr>
<tr>
 <td style="text-align: left;">
    sans serif </td><td style="text-align: left;"> bold italic </td>
</tr>
<tr>
 <td style="text-align: left;">
    script </td><td style="text-align: left;"> plain </td>
</tr>
<tr>
 <td style="text-align: left;">
    script </td><td style="text-align: left;"> italic </td>
</tr>
<tr>
 <td style="text-align: left;">
    script </td><td style="text-align: left;"> bold </td>
</tr>
<tr>
 <td style="text-align: left;">
    gothic english </td><td style="text-align: left;"> plain </td>
</tr>
<tr>
 <td style="text-align: left;">
    gothic german </td><td style="text-align: left;"> plain </td>
</tr>
<tr>
 <td style="text-align: left;">
    gothic italian </td><td style="text-align: left;"> plain </td>
</tr>
<tr>
 <td style="text-align: left;">
    serif symbol </td><td style="text-align: left;"> plain </td>
</tr>
<tr>
 <td style="text-align: left;">
    serif symbol </td><td style="text-align: left;"> italic </td>
</tr>
<tr>
 <td style="text-align: left;">
    serif symbol </td><td style="text-align: left;"> bold </td>
</tr>
<tr>
 <td style="text-align: left;">
    serif symbol </td><td style="text-align: left;"> bold italic </td>
</tr>
<tr>
 <td style="text-align: left;">
    sans serif symbol </td><td style="text-align: left;"> plain </td>
</tr>
<tr>
 <td style="text-align: left;">
    sans serif symbol </td><td style="text-align: left;"> italic </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>


<dl>
<dt>Escape sequences:</dt><dd><p>The string to be drawn can include escape
sequences, which all begin with a <code>\</code>.   When <span class="rlang"><b>R</b></span> encounters a 
<code>\</code>,
rather than drawing the <code>\</code>, it treats the subsequent character(s) 
as a coded description of what to draw.
</p>
<p>One useful escape sequence (in the current context)
is of the form: <code>\123</code>.  The three
digits following the <code>\</code> specify an octal code for a character.  For
example, the octal code for <code>p</code> 
is 160 so the strings <code>"p"</code> and <code>"\160"</code>
are equivalent.  
This is useful for producing characters when  
there is not an appropriate key on your keyboard.
</p>
<p>The other useful escape sequences all begin with <code>\\</code>.  These are
described below.</p>
</dd>
<dt>Symbols:</dt><dd><p>an entire string of Greek symbols can be produced by
selecting the Serif Symbol or Sans Serif Symbol typeface.  To allow
Greek symbols to be embedded in a string which uses a non-symbol typeface,
there are a set of symbol escape sequences of the form <code>\\ab</code>.
For example, the escape sequence <code>\\*a</code> produces a Greek alpha. 
The second table in <code>example(Hershey)</code> shows all of the symbol
escape sequences and the symbols that they produce.</p>
</dd>
<dt>ISO Latin-1:</dt><dd><p>further escape sequences of the form <code>\\ab</code> are 
provided for producing ISO Latin-1 characters (for example, if
you only have a US keyboard).  Another option is to use the appropriate
octal code.  The (non-ASCII) ISO Latin-1 characters are in the range 
241...377.  For example, <code>\366</code> produces the character <code>o</code>
with an 
umlaut.  The third table in <code>example(Hershey)</code> shows all of the
ISO Latin-1 escape sequences.</p>
</dd>
<dt>Special Characters:</dt><dd><p>a set of characters are provided which
do not fall into any standard font.  These can only be accessed by
escape sequence.  For example, <code>\\LI</code> produces the zodiac sign for
Libra, and <code>\\JU</code> produces the astronomical sign for Jupiter.
The fourth table in <code>example(Hershey)</code> shows all of the
special character escape sequences.</p>
</dd>
<dt>Cyrillic Characters:</dt><dd><p>cyrillic characters are implemented 
according to the K018-R encoding.  On a US keyboard, these can be
produced using the Serif typeface and Cyrillic (or Oblique Cyrillic)
fontindex and specifying an octal code in the range 300 to 337 for 
lower case characters or 340 to 377 for upper case characters.
The fifth table in <code>example(Hershey)</code> shows the octal codes for
the available cyrillic characters.</p>
</dd>
<dt>Japanese Characters:</dt><dd><p>83 Hiragana, 86 Katakana, and 603 Kanji
characters are implemented according to the EUC (Extended Unix Code)
encoding.     
Each character is idenitified by a unique hexadecimal code.
The Hiragana characters
are in the range 0x2421 to 0x2473, Katakana are in the range 0x2521 to
0x2576, and Kanji are (scattered about) in the range 0x3021 to 0x6d55.
</p>
<p>When using the Serif typeface and EUC
fontindex, these characters can be produced by a <em>pair</em> of octal
codes.  Given the hexadecimal code (e.g., 0x2421), take the first two
digits and add 0x80 and do the same to the second two digits (e.g., 
0x21 and 0x24 become 0xa4 and 0xa1), then convert both to octal (e.g.,
0xa4 and 0xa1 become 244 and 241).  For example, the first Hiragana
character is produced by <code>\244\241</code>.
</p>
<p>It is also possible to use the hexadecimal code directly.  This works
for all non-EUC fonts by specifying an escape sequence of the form 
<code>\\#J1234</code>.  For example, the first Hiragana character is produced 
by <code>\\#J2421</code>.
</p>
<p>The Kanji characters may be specified in a third way, using the 
so-called &quot;Nelson Index&quot;, by specifying an escape sequence of the form
<code>\\#N1234</code>.  For example, the Kanji for &ldquo;one&rdquo; is
produced by <code>\\#N0001</code>.</p>
</dd>
<dt>Raw Hershey Glyphs:</dt><dd><p>all of the characters in the Hershey fonts 
are stored in a large array.  Some characters are not accessible in
any of the Hershey fonts.  These characters can only be accessed via
an escape sequence of the form <code>\\#H1234</code>.  For example, the
fleur-de-lys is produced by <code>\\#H0746</code>.  The sixth and seventh 
tables of
<code>example(Hershey)</code> shows all of the available raw glyphs.</p>
</dd>
</dl>



<h3>References</h3>

<p><a href="http://www.gnu.org/software/plotutils/plotutils.html">http://www.gnu.org/software/plotutils/plotutils.html</a>
</p>


<h3>See Also</h3>

<p><code>text</code>,
<code>contour</code>,
<code>Japanese</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>######
# create tables of vector font functionality
######
make.table &lt;- function(nr, nc) {
    savepar &lt;- par(mar=rep(0, 4), pty="s")
    plot(c(0, nc*2 + 1), c(0, -(nr + 1)), 
         type="n", xlab="", ylab="", axes=F)
    savepar
}

get.r &lt;- function(i, nr) {
    i %% nr + 1
}

get.c &lt;- function(i, nr) {
    i %/% nr + 1
}

draw.title &lt;- function(title, nr, nc) {
    r &lt;- get.r(i, nr)
    c &lt;- get.c(i, nr)
    text((nc*2 + 1)/2, 0, title, font=2)
}

draw.sample.cell &lt;- function(typeface, fontindex, string, i, nr) {
    r &lt;- get.r(i, nr)
    c &lt;- get.c(i, nr)
    text((2*(c - 1) + 1), -r, paste(typeface, fontindex))
    text((2*c), -r, string, vfont=c(typeface, fontindex), cex=1.5)
    rect((2*(c - 1) + .5), -(r - .5), (2*c + .5), -(r + .5), border="grey")
}

draw.vf.cell &lt;- function(typeface, fontindex, string, i, nr, raw.string=NULL) {
    r &lt;- get.r(i, nr)
    c &lt;- get.c(i, nr)
    if (is.null(raw.string))
        raw.string &lt;- paste("\\", string, sep="")
    text((2*(c - 1) + 1), -r, raw.string, col="grey")
    text((2*c), -r, string, vfont=c(typeface, fontindex))
    rect((2*(c - 1) + .5), -(r - .5), (2*c + .5), -(r + .5), border="grey")
}

nr &lt;- 23
nc &lt;- 1
oldpar &lt;- make.table(nr, nc)
i &lt;- 0
draw.title("Sample 'a' for each available font", nr, nc)
draw.sample.cell("serif", "plain", "a", i, nr); i &lt;- i + 1
draw.sample.cell("serif", "italic", "a", i, nr); i &lt;- i + 1
draw.sample.cell("serif", "bold", "a", i, nr); i &lt;- i + 1
draw.sample.cell("serif", "bold italic", "a", i, nr); i &lt;- i + 1
draw.sample.cell("serif", "cyrillic", "a", i, nr); i &lt;- i + 1
draw.sample.cell("serif", "oblique cyrillic", "a", i, nr); i &lt;- i + 1
draw.sample.cell("serif", "EUC", "a", i, nr); i &lt;- i + 1
draw.sample.cell("sans serif", "plain", "a", i, nr); i &lt;- i + 1
draw.sample.cell("sans serif", "italic", "a", i, nr); i &lt;- i + 1
draw.sample.cell("sans serif", "bold", "a", i, nr); i &lt;- i + 1
draw.sample.cell("sans serif", "bold italic", "a", i, nr); i &lt;- i + 1
draw.sample.cell("script", "plain", "a", i, nr); i &lt;- i + 1
draw.sample.cell("script", "italic", "a", i, nr); i &lt;- i + 1
draw.sample.cell("script", "bold", "a", i, nr); i &lt;- i + 1
draw.sample.cell("gothic english", "plain", "a", i, nr); i &lt;- i + 1
draw.sample.cell("gothic german", "plain", "a", i, nr); i &lt;- i + 1
draw.sample.cell("gothic italian", "plain", "a", i, nr); i &lt;- i + 1
draw.sample.cell("serif symbol", "plain", "a", i, nr); i &lt;- i + 1
draw.sample.cell("serif symbol", "italic", "a", i, nr); i &lt;- i + 1
draw.sample.cell("serif symbol", "bold", "a", i, nr); i &lt;- i + 1
draw.sample.cell("serif symbol", "bold italic", "a", i, nr); i &lt;- i + 1
draw.sample.cell("sans serif symbol", "plain", "a", i, nr); i &lt;- i + 1
draw.sample.cell("sans serif symbol", "italic", "a", i, nr); i &lt;- i + 1

nr &lt;- 25
nc &lt;- 6
tf &lt;- "serif"
fi &lt;- "plain"
make.table(nr, nc)
i &lt;- 0
draw.title("Symbol Escape Sequences", nr, nc)
draw.vf.cell(tf, fi, "\\fa", i, nr); i&lt;-i+1; { "universal"}
draw.vf.cell(tf, fi, "\\te", i, nr); i&lt;-i+1; { "existential"}
draw.vf.cell(tf, fi, "\\st", i, nr); i&lt;-i+1; { "suchthat"}
draw.vf.cell(tf, fi, "\\**", i, nr); i&lt;-i+1; { "asteriskmath"}
draw.vf.cell(tf, fi, "\\=~", i, nr); i&lt;-i+1; { "congruent"}
draw.vf.cell(tf, fi, "\\*A", i, nr); i&lt;-i+1; { "Alpha"}
draw.vf.cell(tf, fi, "\\*B", i, nr); i&lt;-i+1; { "Beta"}
draw.vf.cell(tf, fi, "\\*X", i, nr); i&lt;-i+1; { "Chi"}
draw.vf.cell(tf, fi, "\\*D", i, nr); i&lt;-i+1; { "Delta"}
draw.vf.cell(tf, fi, "\\*E", i, nr); i&lt;-i+1; { "Epsilon"}
draw.vf.cell(tf, fi, "\\*F", i, nr); i&lt;-i+1; { "Phi"}
draw.vf.cell(tf, fi, "\\*G", i, nr); i&lt;-i+1; { "Gamma"}
draw.vf.cell(tf, fi, "\\*Y", i, nr); i&lt;-i+1; { "Eta"}
draw.vf.cell(tf, fi, "\\*I", i, nr); i&lt;-i+1; { "Iota"}
draw.vf.cell(tf, fi, "\\+h", i, nr); i&lt;-i+1; { "theta1"}
draw.vf.cell(tf, fi, "\\*K", i, nr); i&lt;-i+1; { "kappa"}
draw.vf.cell(tf, fi, "\\*L", i, nr); i&lt;-i+1; { "Lambda"}
draw.vf.cell(tf, fi, "\\*M", i, nr); i&lt;-i+1; { "Mu"}
draw.vf.cell(tf, fi, "\\*N", i, nr); i&lt;-i+1; { "Nu"}
draw.vf.cell(tf, fi, "\\*O", i, nr); i&lt;-i+1; { "Omicron"}
draw.vf.cell(tf, fi, "\\*P", i, nr); i&lt;-i+1; { "Pi"}
draw.vf.cell(tf, fi, "\\*H", i, nr); i&lt;-i+1; { "Theta"}
draw.vf.cell(tf, fi, "\\*R", i, nr); i&lt;-i+1; { "Rho"}
draw.vf.cell(tf, fi, "\\*S", i, nr); i&lt;-i+1; { "Sigma"}
draw.vf.cell(tf, fi, "\\*T", i, nr); i&lt;-i+1; { "Tau"}
draw.vf.cell(tf, fi, "\\*U", i, nr); i&lt;-i+1; { "Upsilon"}
draw.vf.cell(tf, fi, "\\ts", i, nr); i&lt;-i+1; { "sigma1"}
draw.vf.cell(tf, fi, "\\*W", i, nr); i&lt;-i+1; { "Omega"}
draw.vf.cell(tf, fi, "\\*C", i, nr); i&lt;-i+1; { "Xi"}
draw.vf.cell(tf, fi, "\\*Q", i, nr); i&lt;-i+1; { "Psi"}
draw.vf.cell(tf, fi, "\\*Z", i, nr); i&lt;-i+1; { "Zeta"}
draw.vf.cell(tf, fi, "\\tf", i, nr); i&lt;-i+1; { "therefore"}
draw.vf.cell(tf, fi, "\\pp", i, nr); i&lt;-i+1; { "perpendicular"}
draw.vf.cell(tf, fi, "\\ul", i, nr); i&lt;-i+1; { "underline"}	
draw.vf.cell(tf, fi, "\\rx", i, nr); i&lt;-i+1; { "radicalex"}
draw.vf.cell(tf, fi, "\\*a", i, nr); i&lt;-i+1; { "alpha"}
draw.vf.cell(tf, fi, "\\*b", i, nr); i&lt;-i+1; { "beta"}
draw.vf.cell(tf, fi, "\\*x", i, nr); i&lt;-i+1; { "chi"}
draw.vf.cell(tf, fi, "\\*d", i, nr); i&lt;-i+1; { "delta"}
draw.vf.cell(tf, fi, "\\*e", i, nr); i&lt;-i+1; { "epsilon"}
draw.vf.cell(tf, fi, "\\*f", i, nr); i&lt;-i+1; { "phi"}
draw.vf.cell(tf, fi, "\\*g", i, nr); i&lt;-i+1; { "gamma"}
draw.vf.cell(tf, fi, "\\*y", i, nr); i&lt;-i+1; { "eta"}
draw.vf.cell(tf, fi, "\\*i", i, nr); i&lt;-i+1; { "iota"}
draw.vf.cell(tf, fi, "\\+f", i, nr); i&lt;-i+1; { "phi1"}
draw.vf.cell(tf, fi, "\\*k", i, nr); i&lt;-i+1; { "kappa"}
draw.vf.cell(tf, fi, "\\*l", i, nr); i&lt;-i+1; { "lambda"}
draw.vf.cell(tf, fi, "\\*m", i, nr); i&lt;-i+1; { "mu"}
draw.vf.cell(tf, fi, "\\*n", i, nr); i&lt;-i+1; { "nu"}
draw.vf.cell(tf, fi, "\\*o", i, nr); i&lt;-i+1; { "omicron"}
draw.vf.cell(tf, fi, "\\*p", i, nr); i&lt;-i+1; { "pi"}
draw.vf.cell(tf, fi, "\\*h", i, nr); i&lt;-i+1; { "theta"}
draw.vf.cell(tf, fi, "\\*r", i, nr); i&lt;-i+1; { "rho"}
draw.vf.cell(tf, fi, "\\*s", i, nr); i&lt;-i+1; { "sigma"}
draw.vf.cell(tf, fi, "\\*t", i, nr); i&lt;-i+1; { "tau"}
draw.vf.cell(tf, fi, "\\*u", i, nr); i&lt;-i+1; { "upsilon"}
draw.vf.cell(tf, fi, "\\+p", i, nr); i&lt;-i+1; { "omega1"}
draw.vf.cell(tf, fi, "\\*w", i, nr); i&lt;-i+1; { "omega"}
draw.vf.cell(tf, fi, "\\*c", i, nr); i&lt;-i+1; { "xi"}
draw.vf.cell(tf, fi, "\\*q", i, nr); i&lt;-i+1; { "psi"}
draw.vf.cell(tf, fi, "\\*z", i, nr); i&lt;-i+1; { "zeta"}
draw.vf.cell(tf, fi, "\\ap", i, nr); i&lt;-i+1; { "similar"}
draw.vf.cell(tf, fi, "\\+U", i, nr); i&lt;-i+1; { "Upsilon1"}
draw.vf.cell(tf, fi, "\\fm", i, nr); i&lt;-i+1; { "minute"}
draw.vf.cell(tf, fi, "\\&lt;=", i, nr); i&lt;-i+1; { "lessequal"}
draw.vf.cell(tf, fi, "\\f/", i, nr); i&lt;-i+1; { "fraction"}
draw.vf.cell(tf, fi, "\\if", i, nr); i&lt;-i+1; { "infinity"}
draw.vf.cell(tf, fi, "\\Fn", i, nr); i&lt;-i+1; { "florin"}
draw.vf.cell(tf, fi, "\\CL", i, nr); i&lt;-i+1; { "club"}
draw.vf.cell(tf, fi, "\\DI", i, nr); i&lt;-i+1; { "diamond"}
draw.vf.cell(tf, fi, "\\HE", i, nr); i&lt;-i+1; { "heart"}
draw.vf.cell(tf, fi, "\\SP", i, nr); i&lt;-i+1; { "spade"}
draw.vf.cell(tf, fi, "\\&lt;&gt;", i, nr); i&lt;-i+1; { "arrowboth"}
draw.vf.cell(tf, fi, "\\&lt;-", i, nr); i&lt;-i+1; { "arrowleft"}
draw.vf.cell(tf, fi, "\\ua", i, nr); i&lt;-i+1; { "arrowup"}
draw.vf.cell(tf, fi, "\\-&gt;", i, nr); i&lt;-i+1; { "arrowright"}
draw.vf.cell(tf, fi, "\\da", i, nr); i&lt;-i+1; { "arrowdown"}
draw.vf.cell(tf, fi, "\\de", i, nr); i&lt;-i+1; { "degree"}
draw.vf.cell(tf, fi, "\\+-", i, nr); i&lt;-i+1; { "plusminus"}
draw.vf.cell(tf, fi, "\\sd", i, nr); i&lt;-i+1; { "second"}
draw.vf.cell(tf, fi, "\\&gt;=", i, nr); i&lt;-i+1; { "greaterequal"}
draw.vf.cell(tf, fi, "\\mu", i, nr); i&lt;-i+1; { "multiply"}
draw.vf.cell(tf, fi, "\\pt", i, nr); i&lt;-i+1; { "proportional"}
draw.vf.cell(tf, fi, "\\pd", i, nr); i&lt;-i+1; { "partialdiff"}
draw.vf.cell(tf, fi, "\\bu", i, nr); i&lt;-i+1; { "bullet"}
draw.vf.cell(tf, fi, "\\di", i, nr); i&lt;-i+1; { "divide"}
draw.vf.cell(tf, fi, "\\!=", i, nr); i&lt;-i+1; { "notequal"}
draw.vf.cell(tf, fi, "\\==", i, nr); i&lt;-i+1; { "equivalence"}
draw.vf.cell(tf, fi, "\\~~", i, nr); i&lt;-i+1; { "approxequal"}
draw.vf.cell(tf, fi, "\\..", i, nr); i&lt;-i+1; { "ellipsis"}
draw.vf.cell(tf, fi, "\\an", i, nr); i&lt;-i+1; { "arrowhorizex"}
draw.vf.cell(tf, fi, "\\CR", i, nr); i&lt;-i+1; { "carriagereturn"}
draw.vf.cell(tf, fi, "\\Ah", i, nr); i&lt;-i+1; { "aleph"}
draw.vf.cell(tf, fi, "\\Im", i, nr); i&lt;-i+1; { "Ifraktur"}
draw.vf.cell(tf, fi, "\\Re", i, nr); i&lt;-i+1; { "Rfraktur"}
draw.vf.cell(tf, fi, "\\wp", i, nr); i&lt;-i+1; { "weierstrass"}
draw.vf.cell(tf, fi, "\\c*", i, nr); i&lt;-i+1; { "circlemultiply"}
draw.vf.cell(tf, fi, "\\c+", i, nr); i&lt;-i+1; { "circleplus"}
draw.vf.cell(tf, fi, "\\es", i, nr); i&lt;-i+1; { "emptyset"}
draw.vf.cell(tf, fi, "\\ca", i, nr); i&lt;-i+1; { "cap"}
draw.vf.cell(tf, fi, "\\cu", i, nr); i&lt;-i+1; { "cup"}
draw.vf.cell(tf, fi, "\\SS", i, nr); i&lt;-i+1; { "superset"}	
draw.vf.cell(tf, fi, "\\ip", i, nr); i&lt;-i+1; { "reflexsuperset"}
draw.vf.cell(tf, fi, "\\n&lt;", i, nr); i&lt;-i+1; { "notsubset"}
draw.vf.cell(tf, fi, "\\SB", i, nr); i&lt;-i+1; { "subset"}	
draw.vf.cell(tf, fi, "\\ib", i, nr); i&lt;-i+1; { "reflexsubset"}
draw.vf.cell(tf, fi, "\\mo", i, nr); i&lt;-i+1; { "element"}
draw.vf.cell(tf, fi, "\\nm", i, nr); i&lt;-i+1; { "notelement"}
draw.vf.cell(tf, fi, "\\/_", i, nr); i&lt;-i+1; { "angle"}
draw.vf.cell(tf, fi, "\\gr", i, nr); i&lt;-i+1; { "nabla"}
draw.vf.cell(tf, fi, "\\rg", i, nr); i&lt;-i+1; { "registerserif"}
draw.vf.cell(tf, fi, "\\co", i, nr); i&lt;-i+1; { "copyrightserif"}
draw.vf.cell(tf, fi, "\\tm", i, nr); i&lt;-i+1; { "trademarkserif"}
draw.vf.cell(tf, fi, "\\PR", i, nr); i&lt;-i+1; { "product"}
draw.vf.cell(tf, fi, "\\sr", i, nr); i&lt;-i+1; { "radical"}
draw.vf.cell(tf, fi, "\\md", i, nr); i&lt;-i+1; { "dotmath"}
draw.vf.cell(tf, fi, "\\no", i, nr); i&lt;-i+1; { "logicalnot"}
draw.vf.cell(tf, fi, "\\AN", i, nr); i&lt;-i+1; { "logicaland"}
draw.vf.cell(tf, fi, "\\OR", i, nr); i&lt;-i+1; { "logicalor"}
draw.vf.cell(tf, fi, "\\hA", i, nr); i&lt;-i+1; { "arrowdblboth"}
draw.vf.cell(tf, fi, "\\lA", i, nr); i&lt;-i+1; { "arrowdblleft"}
draw.vf.cell(tf, fi, "\\uA", i, nr); i&lt;-i+1; { "arrowdblup"}
draw.vf.cell(tf, fi, "\\rA", i, nr); i&lt;-i+1; { "arrowdblright"}
draw.vf.cell(tf, fi, "\\dA", i, nr); i&lt;-i+1; { "arrowdbldown"}
draw.vf.cell(tf, fi, "\\lz", i, nr); i&lt;-i+1; { "lozenge"}
draw.vf.cell(tf, fi, "\\la", i, nr); i&lt;-i+1; { "angleleft"}
draw.vf.cell(tf, fi, "\\RG", i, nr); i&lt;-i+1; { "registersans"}
draw.vf.cell(tf, fi, "\\CO", i, nr); i&lt;-i+1; { "copyrightsans"}
draw.vf.cell(tf, fi, "\\TM", i, nr); i&lt;-i+1; { "trademarksans"}
draw.vf.cell(tf, fi, "\\SU", i, nr); i&lt;-i+1; { "summation"}
draw.vf.cell(tf, fi, "\\lc", i, nr); i&lt;-i+1; { "bracketlefttp"}
draw.vf.cell(tf, fi, "\\lf", i, nr); i&lt;-i+1; { "bracketleftbt"}
draw.vf.cell(tf, fi, "\\ra", i, nr); i&lt;-i+1; { "angleright"}
draw.vf.cell(tf, fi, "\\is", i, nr); i&lt;-i+1; { "integral"}
draw.vf.cell(tf, fi, "\\rc", i, nr); i&lt;-i+1; { "bracketrighttp"}
draw.vf.cell(tf, fi, "\\rf", i, nr); i&lt;-i+1; { "bracketrightbt"}
draw.vf.cell(tf, fi, "\\~=", i, nr); i&lt;-i+1; { "congruent"}
draw.vf.cell(tf, fi, "\\pr", i, nr); i&lt;-i+1; { "minute"}
draw.vf.cell(tf, fi, "\\in", i, nr); i&lt;-i+1; { "infinity"}
draw.vf.cell(tf, fi, "\\n=", i, nr); i&lt;-i+1; { "notequal"}
draw.vf.cell(tf, fi, "\\dl", i, nr); i&lt;-i+1; { "nabla"}

nr &lt;- 25
nc &lt;- 4
make.table(nr, nc)
i &lt;- 0
draw.title("ISO Latin-1 Escape Sequences", nr, nc)
draw.vf.cell(tf, fi, "\\r!", i, nr); i&lt;-i+1; { "exclamdown"}
draw.vf.cell(tf, fi, "\\ct", i, nr); i&lt;-i+1; { "cent"}
draw.vf.cell(tf, fi, "\\Po", i, nr); i&lt;-i+1; { "sterling"}
draw.vf.cell(tf, fi, "\\Ye", i, nr); i&lt;-i+1; { "yen"}
draw.vf.cell(tf, fi, "\\bb", i, nr); i&lt;-i+1; { "brokenbar"}
draw.vf.cell(tf, fi, "\\sc", i, nr); i&lt;-i+1; { "section"}
draw.vf.cell(tf, fi, "\\ad", i, nr); i&lt;-i+1; { "dieresis"}
draw.vf.cell(tf, fi, "\\co", i, nr); i&lt;-i+1; { "copyright"}
draw.vf.cell(tf, fi, "\\Of", i, nr); i&lt;-i+1; { "ordfeminine"}
draw.vf.cell(tf, fi, "\\no", i, nr); i&lt;-i+1; { "logicalnot"}
draw.vf.cell(tf, fi, "\\hy", i, nr); i&lt;-i+1; { "hyphen"}
draw.vf.cell(tf, fi, "\\rg", i, nr); i&lt;-i+1; { "registered"}
draw.vf.cell(tf, fi, "\\a-", i, nr); i&lt;-i+1; { "macron"}
draw.vf.cell(tf, fi, "\\de", i, nr); i&lt;-i+1; { "degree"}
draw.vf.cell(tf, fi, "\\+-", i, nr); i&lt;-i+1; { "plusminus"}
draw.vf.cell(tf, fi, "\\S2", i, nr); i&lt;-i+1; { "twosuperior"}
draw.vf.cell(tf, fi, "\\S3", i, nr); i&lt;-i+1; { "threesuperior"}
draw.vf.cell(tf, fi, "\\aa", i, nr); i&lt;-i+1; { "acute"}
draw.vf.cell(tf, fi, "\\*m", i, nr); i&lt;-i+1; { "mu"}
draw.vf.cell(tf, fi, "\\md", i, nr); i&lt;-i+1; { "periodcentered"}
draw.vf.cell(tf, fi, "\\S1", i, nr); i&lt;-i+1; { "onesuperior"}
draw.vf.cell(tf, fi, "\\Om", i, nr); i&lt;-i+1; { "ordmasculine"}
draw.vf.cell(tf, fi, "\\14", i, nr); i&lt;-i+1; { "onequarter"}
draw.vf.cell(tf, fi, "\\12", i, nr); i&lt;-i+1; { "onehalf"}
draw.vf.cell(tf, fi, "\\34", i, nr); i&lt;-i+1; { "threequarters"}
draw.vf.cell(tf, fi, "\\r?", i, nr); i&lt;-i+1; { "questiondown"}
draw.vf.cell(tf, fi, "\\`A", i, nr); i&lt;-i+1; { "Agrave"}
draw.vf.cell(tf, fi, "\\'A", i, nr); i&lt;-i+1; { "Aacute"}
draw.vf.cell(tf, fi, "\\^A", i, nr); i&lt;-i+1; { "Acircumflex"}
draw.vf.cell(tf, fi, "\\~A", i, nr); i&lt;-i+1; { "Atilde"}
draw.vf.cell(tf, fi, "\\:A", i, nr); i&lt;-i+1; { "Adieresis"}
draw.vf.cell(tf, fi, "\\oA", i, nr); i&lt;-i+1; { "Aring"}
draw.vf.cell(tf, fi, "\\AE", i, nr); i&lt;-i+1; { "AE"}
draw.vf.cell(tf, fi, "\\,C", i, nr); i&lt;-i+1; { "Ccedilla"}
draw.vf.cell(tf, fi, "\\`E", i, nr); i&lt;-i+1; { "Egrave"}
draw.vf.cell(tf, fi, "\\'E", i, nr); i&lt;-i+1; { "Eacute"}
draw.vf.cell(tf, fi, "\\^E", i, nr); i&lt;-i+1; { "Ecircumflex"}
draw.vf.cell(tf, fi, "\\:E", i, nr); i&lt;-i+1; { "Edieresis"}
draw.vf.cell(tf, fi, "\\`I", i, nr); i&lt;-i+1; { "Igrave"}
draw.vf.cell(tf, fi, "\\'I", i, nr); i&lt;-i+1; { "Iacute"}
draw.vf.cell(tf, fi, "\\^I", i, nr); i&lt;-i+1; { "Icircumflex"}
draw.vf.cell(tf, fi, "\\:I", i, nr); i&lt;-i+1; { "Idieresis"}
draw.vf.cell(tf, fi, "\\~N", i, nr); i&lt;-i+1; { "Ntilde"}
draw.vf.cell(tf, fi, "\\`O", i, nr); i&lt;-i+1; { "Ograve"}
draw.vf.cell(tf, fi, "\\'O", i, nr); i&lt;-i+1; { "Oacute"}
draw.vf.cell(tf, fi, "\\^O", i, nr); i&lt;-i+1; { "Ocircumflex"}
draw.vf.cell(tf, fi, "\\~O", i, nr); i&lt;-i+1; { "Otilde"}
draw.vf.cell(tf, fi, "\\:O", i, nr); i&lt;-i+1; { "Odieresis"}
draw.vf.cell(tf, fi, "\\mu", i, nr); i&lt;-i+1; { "multiply"}
draw.vf.cell(tf, fi, "\\/O", i, nr); i&lt;-i+1; { "Oslash"}
draw.vf.cell(tf, fi, "\\`U", i, nr); i&lt;-i+1; { "Ugrave"}
draw.vf.cell(tf, fi, "\\'U", i, nr); i&lt;-i+1; { "Uacute"}
draw.vf.cell(tf, fi, "\\^U", i, nr); i&lt;-i+1; { "Ucircumflex"}
draw.vf.cell(tf, fi, "\\:U", i, nr); i&lt;-i+1; { "Udieresis"}
draw.vf.cell(tf, fi, "\\'Y", i, nr); i&lt;-i+1; { "Yacute"}
draw.vf.cell(tf, fi, "\\ss", i, nr); i&lt;-i+1; { "germandbls"}
draw.vf.cell(tf, fi, "\\`a", i, nr); i&lt;-i+1; { "agrave"}
draw.vf.cell(tf, fi, "\\'a", i, nr); i&lt;-i+1; { "aacute"}
draw.vf.cell(tf, fi, "\\^a", i, nr); i&lt;-i+1; { "acircumflex"}
draw.vf.cell(tf, fi, "\\~a", i, nr); i&lt;-i+1; { "atilde"}
draw.vf.cell(tf, fi, "\\:a", i, nr); i&lt;-i+1; { "adieresis"}
draw.vf.cell(tf, fi, "\\oa", i, nr); i&lt;-i+1; { "aring"}
draw.vf.cell(tf, fi, "\\ae", i, nr); i&lt;-i+1; { "ae"}
draw.vf.cell(tf, fi, "\\,c", i, nr); i&lt;-i+1; { "ccedilla"}
draw.vf.cell(tf, fi, "\\`e", i, nr); i&lt;-i+1; { "egrave"}
draw.vf.cell(tf, fi, "\\'e", i, nr); i&lt;-i+1; { "eacute"}
draw.vf.cell(tf, fi, "\\^e", i, nr); i&lt;-i+1; { "ecircumflex"}
draw.vf.cell(tf, fi, "\\:e", i, nr); i&lt;-i+1; { "edieresis"}
draw.vf.cell(tf, fi, "\\`i", i, nr); i&lt;-i+1; { "igrave"}
draw.vf.cell(tf, fi, "\\'i", i, nr); i&lt;-i+1; { "iacute"}
draw.vf.cell(tf, fi, "\\^i", i, nr); i&lt;-i+1; { "icircumflex"}
draw.vf.cell(tf, fi, "\\:i", i, nr); i&lt;-i+1; { "idieresis"}
draw.vf.cell(tf, fi, "\\~n", i, nr); i&lt;-i+1; { "ntilde"}
draw.vf.cell(tf, fi, "\\`o", i, nr); i&lt;-i+1; { "ograve"}
draw.vf.cell(tf, fi, "\\'o", i, nr); i&lt;-i+1; { "oacute"}
draw.vf.cell(tf, fi, "\\^o", i, nr); i&lt;-i+1; { "ocircumflex"}
draw.vf.cell(tf, fi, "\\~o", i, nr); i&lt;-i+1; { "otilde"}
draw.vf.cell(tf, fi, "\\:o", i, nr); i&lt;-i+1; { "odieresis"}
draw.vf.cell(tf, fi, "\\di", i, nr); i&lt;-i+1; { "divide"}
draw.vf.cell(tf, fi, "\\/o", i, nr); i&lt;-i+1; { "oslash"}
draw.vf.cell(tf, fi, "\\`u", i, nr); i&lt;-i+1; { "ugrave"}
draw.vf.cell(tf, fi, "\\'u", i, nr); i&lt;-i+1; { "uacute"}
draw.vf.cell(tf, fi, "\\^u", i, nr); i&lt;-i+1; { "ucircumflex"}
draw.vf.cell(tf, fi, "\\:u", i, nr); i&lt;-i+1; { "udieresis"}
draw.vf.cell(tf, fi, "\\'y", i, nr); i&lt;-i+1; { "yacute"}
draw.vf.cell(tf, fi, "\\:y", i, nr); i&lt;-i+1; { "ydieresis"}

nr &lt;- 25
nc &lt;- 2
make.table(nr, nc)
i &lt;- 0
draw.title("Special Escape Sequences", nr, nc)
draw.vf.cell(tf, fi, "\\AR", i, nr); i&lt;-i+1; { "aries"}
draw.vf.cell(tf, fi, "\\TA", i, nr); i&lt;-i+1; { "taurus"}
draw.vf.cell(tf, fi, "\\GE", i, nr); i&lt;-i+1; { "gemini"}
draw.vf.cell(tf, fi, "\\CA", i, nr); i&lt;-i+1; { "cancer"}
draw.vf.cell(tf, fi, "\\LE", i, nr); i&lt;-i+1; { "leo"}
draw.vf.cell(tf, fi, "\\VI", i, nr); i&lt;-i+1; { "virgo"}
draw.vf.cell(tf, fi, "\\LI", i, nr); i&lt;-i+1; { "libra"}
draw.vf.cell(tf, fi, "\\SC", i, nr); i&lt;-i+1; { "scorpio"}
draw.vf.cell(tf, fi, "\\SG", i, nr); i&lt;-i+1; { "sagittarius"}
draw.vf.cell(tf, fi, "\\CP", i, nr); i&lt;-i+1; { "capricornus"}
draw.vf.cell(tf, fi, "\\AQ", i, nr); i&lt;-i+1; { "aquarius"}
draw.vf.cell(tf, fi, "\\PI", i, nr); i&lt;-i+1; { "pisces"}
draw.vf.cell(tf, fi, "\\~-", i, nr); i&lt;-i+1; { "modifiedcongruent"}
draw.vf.cell(tf, fi, "\\hb", i, nr); i&lt;-i+1; { "hbar"}
draw.vf.cell(tf, fi, "\\IB", i, nr); i&lt;-i+1; { "interbang"}
draw.vf.cell(tf, fi, "\\Lb", i, nr); i&lt;-i+1; { "lambdabar"}
draw.vf.cell(tf, fi, "\\UD", i, nr); i&lt;-i+1; { "undefined"}
draw.vf.cell(tf, fi, "\\SO", i, nr); i&lt;-i+1; { "sun"}
draw.vf.cell(tf, fi, "\\ME", i, nr); i&lt;-i+1; { "mercury"}
draw.vf.cell(tf, fi, "\\VE", i, nr); i&lt;-i+1; { "venus"}
draw.vf.cell(tf, fi, "\\EA", i, nr); i&lt;-i+1; { "earth"}
draw.vf.cell(tf, fi, "\\MA", i, nr); i&lt;-i+1; { "mars"}
draw.vf.cell(tf, fi, "\\JU", i, nr); i&lt;-i+1; { "jupiter"}
draw.vf.cell(tf, fi, "\\SA", i, nr); i&lt;-i+1; { "saturn"}
draw.vf.cell(tf, fi, "\\UR", i, nr); i&lt;-i+1; { "uranus"}
draw.vf.cell(tf, fi, "\\NE", i, nr); i&lt;-i+1; { "neptune"}
draw.vf.cell(tf, fi, "\\PL", i, nr); i&lt;-i+1; { "pluto"}
draw.vf.cell(tf, fi, "\\LU", i, nr); i&lt;-i+1; { "moon"}
draw.vf.cell(tf, fi, "\\CT", i, nr); i&lt;-i+1; { "comet"}
draw.vf.cell(tf, fi, "\\ST", i, nr); i&lt;-i+1; { "star"}
draw.vf.cell(tf, fi, "\\AS", i, nr); i&lt;-i+1; { "ascendingnode"}
draw.vf.cell(tf, fi, "\\DE", i, nr); i&lt;-i+1; { "descendingnode"}
draw.vf.cell(tf, fi, "\\s-", i, nr); i&lt;-i+1; { "s1"}
draw.vf.cell(tf, fi, "\\dg", i, nr); i&lt;-i+1; { "dagger"}
draw.vf.cell(tf, fi, "\\dd", i, nr); i&lt;-i+1; { "daggerdbl"}
draw.vf.cell(tf, fi, "\\li", i, nr); i&lt;-i+1; { "line integral"}
draw.vf.cell(tf, fi, "\\-+", i, nr); i&lt;-i+1; { "minusplus"}
draw.vf.cell(tf, fi, "\\||", i, nr); i&lt;-i+1; { "parallel"}
draw.vf.cell(tf, fi, "\\rn", i, nr); i&lt;-i+1; { "overscore"}
draw.vf.cell(tf, fi, "\\ul", i, nr); i&lt;-i+1; { "underscore"}

nr &lt;- 25
nc &lt;- 3
make.table(nr, nc)
i &lt;- 0
code &lt;- c(300:307,310:317,320:327,330:337,340:347,350:357,360:367,370:377,
          243,263)
string &lt;- c(
"\300","\301","\302","\303","\304","\305","\306","\307",
"\310","\311","\312","\313","\314","\315",
"\316","\317","\320","\321","\322","\323",
"\324","\325","\326","\327","\330","\331",
"\332","\333","\334","\335","\336","\337",
"\340","\341","\342","\343","\344","\345","\346","\347",
"\350","\351","\352","\353","\354","\355",
"\356","\357","\360","\361","\362","\363",
"\364","\365","\366","\367","\370","\371",
"\372","\373","\374","\375","\376","\377","\243","\263")
draw.title("Cyrillic Octal Codes", nr ,nc)
for (i in 1:66)
    draw.vf.cell(tf, "cyrillic", string[i], i-1, nr, 
                 raw.string=paste("\\", as.character(code[i]), sep=""))

nr &lt;- 25
nc &lt;- 3
make.table(nr, nc)
i &lt;- 0
code &lt;- c(252,254,256,262:269,275,278:281,284,745,746,750:768,796:802,
          804:807,809,814:828,830:834,840:844)
draw.title("Raw Hershey Escape Sequences", nr, nc)
for (i in 1:75)
    draw.vf.cell(tf, fi, paste("\\#H",formatC(code[i],wid=4,flag=0),sep=""), 
                 i-1, nr)
make.table(nr, nc)
i &lt;- 0
code &lt;- c(845:847,850:856,860:874,899:909,2296:2299,2318:2332,2367:2382,
          4014,4109)
draw.title("More Raw Hershey Escape Sequences", nr, nc)
for (i in 1:73)
    draw.vf.cell(tf, fi, paste("\\#H",formatC(code[i],wid=4,flag=0),sep=""), 
                 i-1, nr)

par(oldpar)
</code></pre>

<hr /><div style="text-align: center;">[<a href='/r-help/1.0/00index.html'>Package <em>base</em> version 1.0</a> ]</div>
</div>
</body></html>
