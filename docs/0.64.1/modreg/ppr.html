<!DOCTYPE html><html><head><title>R: Projection Pursuit Regression</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body> <div style='padding: 20pt; border: 2px solid black; text-align:center;'><b>This help topic is for R version 0.64.1. For the corresponding topic in the current version of R, see <a href='https://stat.ethz.ch/R-manual/R-patched/library/modreg/html/ppr.html'>https://stat.ethz.ch/R-manual/R-patched/library/modreg/html/ppr.html</a></b></div><div class="container">

<table style="width: 100%;"><tr><td>ppr {modreg}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2 id='ppr'>
Projection Pursuit Regression
</h2>

<h3>Description</h3>

<p>The basic method is given by Friedman (1984), and is essentially the
same code used by S's <code>ppreg</code>.  The answers will be very similar on a given
machine, but this code is extremely sensitive to the compiler used.
The differences are the ability to use spline smoothers and the
interface which should be much easier to use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ppr(formula, data=sys.parent(), weights,
    subset, na.action, contrasts=NULL,

    ww=rep(1,q), nterms, max.terms=nterms, optlevel=2, 
    sm.method=c("supsmu", "spline", "gcvspline"),
    bass=0, span=0, df=5, gcvpen=1)

ppr(x, y, weights=rep(1,n),
    ww=...... (as above) ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ppr_:_formula">formula</code></td>
<td>

<p>a regression formula specifying one or more response variables and the
explanatory variables.
</p>
</td></tr>
<tr><td><code id="ppr_:_x">x</code></td>
<td>

<p>matrix of explanatory variables.  Rows represent observations, and
columns represent variables.  Missing values are not accepted. 
</p>
</td></tr>
<tr><td><code id="ppr_:_nterms">nterms</code></td>
<td>
<p>number of terms to include in the final model.</p>
</td></tr>
<tr><td><code id="ppr_:_data">data</code></td>
<td>

<p>Data frame from which variables specified in <code>formula</code> are
preferentially to be taken.
</p>
</td></tr>
<tr><td><code id="ppr_:_weights">weights</code></td>
<td>
<p>a vector of weights for each <em>case</em>.</p>
</td></tr>
<tr><td><code id="ppr_:_ww">ww</code></td>
<td>

<p>a vector of weights for each <em>response</em>, so the fit criterion is
the sum over case <code>i</code> and responses <code>j</code> of
<code>w_i ww_j (y_ij - fit_ij)^2</code> divided by the sum of <code>w_i</code>.
</p>
</td></tr>
<tr><td><code id="ppr_:_subset">subset</code></td>
<td>

<p>An index vector specifying the cases to be used in the training
sample.  (NOTE: If given, this argument must be named.)
</p>
</td></tr>
<tr><td><code id="ppr_:_na.action">na.action</code></td>
<td>

<p>A function to specify the action to be taken if <code>NA</code>s are
found. The
default action is for the procedure to fail.  An alternative is
<code>na.omit</code>, which leads to rejection of cases with missing values on
any required variable.  (NOTE: If given, this argument must be named.)
</p>
</td></tr>
<tr><td><code id="ppr_:_contrasts">contrasts</code></td>
<td>

<p>the contrasts to be used when any factor explanatory variables are coded.
</p>
</td></tr>
<tr><td><code id="ppr_:_max.terms">max.terms</code></td>
<td>

<p>maximum number of terms to choose from when building the model.
</p>
</td></tr>
<tr><td><code id="ppr_:_optlevel">optlevel</code></td>
<td>

<p>integer from 0 to 3 which determines the throughness of an
optimization routine in the SMART program. See the <b>Details</b> section.
</p>
</td></tr>
<tr><td><code id="ppr_:_sm.method">sm.method</code></td>
<td>

<p>the method used for smoothing the ridge functions.  The default is to
use Friedman's super smoother <code>supsmu</code>.  The alternatives are to use
the smoothing spline code underlying <code>smooth.spline</code>, either with a
specified (equivalent) degrees of freedom for each ridge functions, or
to allow the smoothness to be chosen by GCV.
</p>
</td></tr>
<tr><td><code id="ppr_:_bass">bass</code></td>
<td>

<p>super smoother bass tone control used with automatic span selection
(see <code>supsmu</code>); the range of values is 0 to 10, with larger values
resulting in increased smoothing.
</p>
</td></tr>
<tr><td><code id="ppr_:_span">span</code></td>
<td>

<p>super smoother span control (see <code>supsmu</code>).  The default, <code>0</code>,
results in automatic span selection by local cross validation. <code>span</code>
can also take a value in <code>(0, 1]</code>.
</p>
</td></tr>
<tr><td><code id="ppr_:_df">df</code></td>
<td>

<p>if <code>sm.method</code> is <code>"spline"</code> specifies the smoothness of each ridge
term via the requested equivalent degrees of freedom.
</p>
</td></tr>
<tr><td><code id="ppr_:_gcvpen">gcvpen</code></td>
<td>

<p>if <code>sm.method</code> is <code>"gcvspline"</code> this is the penalty used in the GCV
selection for each degree of freedom used.
</p>
</td></tr></table>


<h3>Details</h3>

<p>The algorithm first adds up to <code>max.terms</code> ridge terms one at a
time; it will use less if it is unable to find a term to add that makes
sufficient difference.  It then removes the least <em>&quot;important&quot;</em>
term at each step until <code>nterm</code> terms are left.
</p>
<p>The levels of optimization (argument <code>optlevel</code>)
differ in how thoroughly the models are refitted during this process.
At level 0 the existing ridge terms are not refitted.  At level 1
the projection directions are not refitted, but the ridge
functions and the regression coefficients are.

Levels 2 and 3 refit all the terms and are equivalent for one
response; level 3 is more careful to re-balance the contributions
from each regressor at each step and so is a little less likely to
converge to a saddle point of the sum of squares criterion.
</p>


<h3>Value</h3>

<p>A list with the following components, many of which are for use by the
method functions.
</p>
<table>
<tr><td><code>call</code></td>
<td>

<p>the matched call
</p>
</td></tr>
<tr><td><code>p</code></td>
<td>

<p>the number of explanatory variables (after any coding)
</p>
</td></tr>
<tr><td><code>q</code></td>
<td>

<p>the number of response variables
</p>
</td></tr>
<tr><td><code>ml</code></td>
<td>

<p>the argument <code>max.terms</code>
</p>
</td></tr>
<tr><td><code>gof</code></td>
<td>

<p>the overall residual (weighted) sum of squares for the selected model
</p>
</td></tr>
<tr><td><code>gofn</code></td>
<td>

<p>the overall residual (weighted) sum of squares against the number of
terms, up to <code>max.terms</code>.  Will be invalid (and zero) for less than
<code>nterms</code>.
</p>
</td></tr>
<tr><td><code>df</code></td>
<td>

<p>the argument <code>df</code>
</p>
</td></tr>
<tr><td><code>edf</code></td>
<td>

<p>if <code>sm.method</code> is <code>"spline"</code> or <code>"gcvspline"</code> the equivalent number of
degrees of freedom for each ridge term used.
</p>
</td></tr>
<tr><td><code>xnames</code></td>
<td>

<p>the names of the explanatory variables
</p>
</td></tr>
<tr><td><code>ynames</code></td>
<td>

<p>the names of the response variables
</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>

<p>a matrix of the projection directions, with a column for each ridge term
</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>

<p>a matrix of the coefficients applied for each response to the ridge
terms: the rows are the responses and the columns the ridge terms
</p>
</td></tr>
<tr><td><code>yb</code></td>
<td>

<p>the weighted means of each response
</p>
</td></tr>
<tr><td><code>ys</code></td>
<td>

<p>the overall scale factor used: internally the responses are divided by
<code>ys</code> to have unit total weighted sum of squares.
</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>

<p>the fitted values, as a matrix if <code>q &gt; 1</code>
</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>

<p>the residuals, as a matrix if <code>q &gt; 1</code>
</p>
</td></tr>
<tr><td><code>smod</code></td>
<td>

<p>internal work array, which includes the ridge functions evaluated at
the training set points.
</p>
</td></tr></table>


<h3>References</h3>

<p>Friedman, J. H. and Stuetzle, W. (1981)
Projection pursuit regression. 
Journal of the American Statistical Association
<b>76</b>, 817-823.
</p>
<p>Friedman, J. H. (1984)
SMART User's Guide.
Laboratory for Computational Statistics, Stanford University Technical
Report No. 1.
</p>


<h3>See Also</h3>

<p><code>plot.ppr</code>, <code>ppreg</code>, <code>supsmu</code>,
<code>smooth.spline</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Note: your numerical values may differ
data(rock)
attach(rock)
area1 &lt;- area/10000; peri1 &lt;- peri/10000
rock.ppr &lt;- ppr(log(perm) ~ area1 + peri1 + shape,
		data=rock, nterms=2, max.terms=5)
rock.ppr
# Call:
# ppr.formula(formula = log(perm) ~ area1 + peri1 + shape, data = rock, 
#     nterms = 2, max.terms = 5)
#
# Goodness of fit:
#  2 terms  3 terms  4 terms  5 terms 
# 8.737806 5.289517 4.745799 4.490378

summary(rock.ppr)
# .....  (same as above)
# .....
#
# Projection direction vectors:
#       term 1      term 2     
# area1  0.34357179  0.37071027
# peri1 -0.93781471 -0.61923542
# shape  0.04961846  0.69218595
#
# Coefficients of ridge terms:
#    term 1    term 2 
# 1.6079271 0.5460971 

par(mfrow=c(3,2))# maybe: , pty="s")
plot(rock.ppr, main="ppr(log(perm)~ ., nterms=2, max.terms=5)")
plot(update(rock.ppr, bass=5), main = "update(..., bass = 5)")
plot(update(rock.ppr, sm.method="gcv", gcvpen=2),
     main = "update(..., sm.method=\"gcv\", gcvpen=2)")

</code></pre>


</div>
</body></html>
