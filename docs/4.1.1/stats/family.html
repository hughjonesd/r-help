<!DOCTYPE html><html><head><title>R: Family Objects for Models</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body> <div style='padding: 20pt; border: 2px solid black; text-align:center;'><b>This help topic is for R version 4.1.1. For the current version of R, try <a href='https://stat.ethz.ch/R-manual/R-patched/library/stats/html/family.html'>https://stat.ethz.ch/R-manual/R-patched/library/stats/html/family.html</a></b></div><div class="container"><main>

<table style="width: 100%;"><tr><td>family {stats}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Family Objects for Models</h2>

<h3>Description</h3>

<p>Family objects provide a convenient way to specify the details of the
models used by functions such as <code>glm</code>.  See the
documentation for <code>glm</code> for the details on how such model
fitting takes place.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>family(object, ...)

binomial(link = "logit")
gaussian(link = "identity")
Gamma(link = "inverse")
inverse.gaussian(link = "1/mu^2")
poisson(link = "log")
quasi(link = "identity", variance = "constant")
quasibinomial(link = "logit")
quasipoisson(link = "log")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="link">link</code></td>
<td>
<p>a specification for the model link function.  This can be
a name/expression, a literal character string, a length-one character
vector, or an object of class
<code>"link-glm"</code> (such as generated by
<code>make.link</code>) provided it is not specified
<em>via</em> one of the standard names given next.
</p>
<p>The <code>gaussian</code> family accepts the links (as names)
<code>identity</code>, <code>log</code> and <code>inverse</code>;
the <code>binomial</code> family the links <code>logit</code>,
<code>probit</code>, <code>cauchit</code>, (corresponding to logistic,
normal and Cauchy CDFs respectively) <code>log</code> and
<code>cloglog</code> (complementary log-log);
the <code>Gamma</code> family the links <code>inverse</code>, <code>identity</code>
and <code>log</code>;
the <code>poisson</code> family the links <code>log</code>, <code>identity</code>,
and <code>sqrt</code>; and the <code>inverse.gaussian</code> family the links
<code>1/mu^2</code>, <code>inverse</code>, <code>identity</code>
and <code>log</code>.
</p>
<p>The <code>quasi</code> family accepts the links <code>logit</code>, <code>probit</code>,
<code>cloglog</code>,  <code>identity</code>, <code>inverse</code>,
<code>log</code>, <code>1/mu^2</code> and <code>sqrt</code>, and
the function <code>power</code> can be used to create a
power link function.
</p>
</td></tr>
<tr><td><code id="variance">variance</code></td>
<td>
<p>for all families other than <code>quasi</code>, the variance
function is determined by the family.  The <code>quasi</code> family will
accept the literal character string (or unquoted as a name/expression)
specifications <code>"constant"</code>, <code>"mu(1-mu)"</code>, <code>"mu"</code>,
<code>"mu^2"</code> and <code>"mu^3"</code>, a length-one character vector
taking one of those values, or a list containing components
<code>varfun</code>, <code>validmu</code>, <code>dev.resids</code>, <code>initialize</code>
and <code>name</code>.
</p>
</td></tr>
<tr><td><code id="object">object</code></td>
<td>
<p>the function <code>family</code> accesses the <code>family</code>
objects which are stored within objects created by modelling
functions (e.g., <code>glm</code>).</p>
</td></tr>
<tr><td><code id="...">...</code></td>
<td>
<p>further arguments passed to methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>family</code> is a generic function with methods for classes
<code>"glm"</code> and <code>"lm"</code> (the latter returning <code>gaussian()</code>).
</p>
<p>For the <code>binomial</code> and <code>quasibinomial</code> families the response
can be specified in one of three ways:
</p>

<ol>
<li><p> As a factor: &lsquo;success&rsquo; is interpreted as the factor not
having the first level (and hence usually of having the second level).
</p>
</li>
<li><p> As a numerical vector with values  between <code>0</code> and
<code>1</code>, interpreted as the proportion of successful cases (with the
total number of cases given by the <code>weights</code>).
</p>
</li>
<li><p> As a two-column integer matrix: the first column gives the
number of successes and the second the number of failures.
</p>
</li></ol>

<p>The <code>quasibinomial</code> and <code>quasipoisson</code> families differ from
the <code>binomial</code> and <code>poisson</code> families only in that the
dispersion parameter is not fixed at one, so they can model
over-dispersion.  For the binomial case see McCullagh and Nelder
(1989, pp. 124&ndash;8).  Although they show that there is (under some
restrictions) a model with
variance proportional to mean as in the quasi-binomial model, note
that <code>glm</code> does not compute maximum-likelihood estimates in that
model.  The behaviour of S is closer to the quasi- variants.
</p>


<h3>Value</h3>

<p>An object of class <code>"family"</code> (which has a concise print method).
This is a list with elements
</p>
<table role = "presentation">
<tr><td><code>family</code></td>
<td>
<p>character: the family name.</p>
</td></tr>
<tr><td><code>link</code></td>
<td>
<p>character: the link name.</p>
</td></tr>
<tr><td><code>linkfun</code></td>
<td>
<p>function: the link.</p>
</td></tr>
<tr><td><code>linkinv</code></td>
<td>
<p>function: the inverse of the link function.</p>
</td></tr>
<tr><td><code>variance</code></td>
<td>
<p>function: the variance as a function of the mean.</p>
</td></tr>
<tr><td><code>dev.resids</code></td>
<td>
<p>function giving the deviance for each observation
as a function of <code>(y, mu, wt)</code>, used by the
<code>residuals</code> method when computing
deviance residuals.</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p>function giving the AIC value if appropriate (but <code>NA</code>
for the quasi- families).  More precisely, this function
returns <code class="reqn">-2\ell + 2 s</code>, where <code class="reqn">\ell</code> is the
log-likelihood and <code class="reqn">s</code> is the number of estimated scale
parameters.  Note that the penalty term for the location parameters
(typically the &ldquo;regression coefficients&rdquo;) is added elsewhere,
e.g., in <code>glm.fit()</code>, or <code>AIC()</code>, see the
AIC example in <code>glm</code>.
See <code>logLik</code> for the assumptions made about the
dispersion parameter.</p>
</td></tr>
<tr><td><code>mu.eta</code></td>
<td>
<p>function: derivative of the inverse-link function
with respect to the linear predictor.  If the inverse-link
function is <code class="reqn">\mu = g^{-1}(\eta)</code> where
<code class="reqn">\eta</code> is the value of the linear predictor, then this
function returns
<code class="reqn">d(g^{-1})/d\eta = d\mu/d\eta</code>.</p>
</td></tr>
<tr><td><code>initialize</code></td>
<td>
<p>expression.  This needs to set up whatever data
objects are needed for the family as well as <code>n</code> (needed for
AIC in the binomial family) and <code>mustart</code> (see <code>glm</code>).</p>
</td></tr>
<tr><td><code>validmu</code></td>
<td>
<p>logical function.  Returns <code>TRUE</code> if a mean
vector <code>mu</code> is within the domain of <code>variance</code>.</p>
</td></tr>
<tr><td><code>valideta</code></td>
<td>
<p>logical function.   Returns <code>TRUE</code> if a linear
predictor <code>eta</code> is within the domain of <code>linkinv</code>.</p>
</td></tr>
<tr><td><code>simulate</code></td>
<td>
<p>(optional) function <code>simulate(object, nsim)</code> to be
called by the <code>"lm"</code> method of <code>simulate</code>.  It will
normally return a matrix with <code>nsim</code> columns and one row for
each fitted value, but it can also return a list of length
<code>nsim</code>. Clearly this will be missing for &lsquo;quasi-&rsquo; families.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The <code>link</code> and <code>variance</code> arguments have rather awkward
semantics for back-compatibility.  The recommended way is to supply
them as quoted character strings, but they can also be supplied
unquoted (as names or expressions).  Additionally, they can be
supplied as a length-one character vector giving the name of one of
the options, or as a list (for <code>link</code>, of class
<code>"link-glm"</code>).  The restrictions apply only to links given as
names: when given as a character string all the links known to
<code>make.link</code> are accepted.
</p>
<p>This is potentially ambiguous: supplying <code>link = logit</code> could mean
the unquoted name of a link or the value of object <code>logit</code>.  It
is interpreted if possible as the name of an allowed link, then
as an object.  (You can force the interpretation to always be the value of
an object via <code>logit[1]</code>.)
</p>


<h3>Author(s)</h3>

<p>The design was inspired by S functions of the same names described
in Hastie &amp; Pregibon (1992) (except <code>quasibinomial</code> and
<code>quasipoisson</code>).
</p>


<h3>References</h3>

<p>McCullagh P. and Nelder, J. A. (1989)
<em>Generalized Linear Models.</em>
London: Chapman and Hall.
</p>
<p>Dobson, A. J. (1983)
<em>An Introduction to Statistical Modelling.</em>
London: Chapman and Hall.
</p>
<p>Cox, D. R. and  Snell, E. J. (1981).
<em>Applied Statistics; Principles and Examples.</em>
London: Chapman and Hall.
</p>
<p>Hastie, T. J. and Pregibon, D. (1992)
<em>Generalized linear models.</em>
Chapter 6 of <em>Statistical Models in S</em>
eds J. M. Chambers and T. J. Hastie, Wadsworth &amp; Brooks/Cole.
</p>


<h3>See Also</h3>

<p><code>glm</code>, <code>power</code>, <code>make.link</code>.
</p>
<p>For binomial <em>coefficients</em>, <code>choose</code>;
the binomial and negative binomial <em>distributions</em>,
<code>Binomial</code>, and <code>NegBinomial</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(utils) # for str

nf &lt;- gaussian()  # Normal family
nf
str(nf)

gf &lt;- Gamma()
gf
str(gf)
gf$linkinv
gf$variance(-3:4) #- == (.)^2

## Binomial with default 'logit' link:  Check some properties visually:
bi &lt;- binomial()
et &lt;- seq(-10,10, by=1/8)
plot(et, bi$mu.eta(et), type="l")
## show that mu.eta() is derivative of linkinv() :
lines((et[-1]+et[-length(et)])/2, col=adjustcolor("red", 1/4),
      diff(bi$linkinv(et))/diff(et), type="l", lwd=4)
## which here is the logistic density:
lines(et, dlogis(et), lwd=3, col=adjustcolor("blue", 1/4))
stopifnot(exprs = {
  all.equal(bi$ mu.eta(et), dlogis(et))
  all.equal(bi$linkinv(et), plogis(et) -&gt; m)
  all.equal(bi$linkfun(m ), qlogis(m))    #  logit(.) == qlogis(.) !
})

## Data from example(glm) :
d.AD &lt;- data.frame(treatment = gl(3,3),
                   outcome   = gl(3,1,9),
                   counts    = c(18,17,15, 20,10,20, 25,13,12))
glm.D93 &lt;- glm(counts ~ outcome + treatment, d.AD, family = poisson())
## Quasipoisson: compare with above / example(glm) :
glm.qD93 &lt;- glm(counts ~ outcome + treatment, d.AD, family = quasipoisson())

glm.qD93
anova  (glm.qD93, test = "F")
summary(glm.qD93)
## for Poisson results (same as from 'glm.D93' !) use
anova  (glm.qD93, dispersion = 1, test = "Chisq")
summary(glm.qD93, dispersion = 1)



## Example of user-specified link, a logit model for p^days
## See Shaffer, T.  2004. Auk 121(2): 526-540.
logexp &lt;- function(days = 1)
{
    linkfun &lt;- function(mu) qlogis(mu^(1/days))
    linkinv &lt;- function(eta) plogis(eta)^days
    mu.eta  &lt;- function(eta) days * plogis(eta)^(days-1) *
                  binomial()$mu.eta(eta)
    valideta &lt;- function(eta) TRUE
    link &lt;- paste0("logexp(", days, ")")
    structure(list(linkfun = linkfun, linkinv = linkinv,
                   mu.eta = mu.eta, valideta = valideta, name = link),
              class = "link-glm")
}
(bil3 &lt;- binomial(logexp(3)))

## in practice this would be used with a vector of 'days', in
## which case use an offset of 0 in the corresponding formula
## to get the null deviance right.

## Binomial with identity link: often not a good idea, as both
## computationally and conceptually difficult:
binomial(link = "identity")  ## is exactly the same as
binomial(link = make.link("identity"))



## tests of quasi
x &lt;- rnorm(100)
y &lt;- rpois(100, exp(1+x))
glm(y ~ x, family = quasi(variance = "mu", link = "log"))
# which is the same as
glm(y ~ x, family = poisson)
glm(y ~ x, family = quasi(variance = "mu^2", link = "log"))
## Not run: glm(y ~ x, family = quasi(variance = "mu^3", link = "log")) # fails
y &lt;- rbinom(100, 1, plogis(x))
# need to set a starting value for the next fit
glm(y ~ x, family = quasi(variance = "mu(1-mu)", link = "logit"), start = c(0,1))
</code></pre>

<hr /><div style="text-align: center;">[<a href='/r-help/4.1.1/00index.html'>Package <em>stats</em> version 4.1.1</a> ]</div></main>

</div>
</body></html>
