<!DOCTYPE html><html><head><title>R: Perspective Plots</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body> <div style='padding: 20pt; border: 2px solid black; text-align:center;'><b>This help topic is for R version 4.1.3. For the current version of R, try <a href='https://stat.ethz.ch/R-manual/R-patched/library/graphics/html/persp.html'>https://stat.ethz.ch/R-manual/R-patched/library/graphics/html/persp.html</a></b></div><div class="container"><main>

<table style="width: 100%;"><tr><td>persp {graphics}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Perspective Plots</h2>

<h3>Description</h3>

<p>This function draws perspective plots of a surface over the
x&ndash;y plane.  <code>persp</code> is a generic function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>persp(x, ...)

## Default S3 method:
persp(x = seq(0, 1, length.out = nrow(z)),
      y = seq(0, 1, length.out = ncol(z)),
      z, xlim = range(x), ylim = range(y),
      zlim = range(z, na.rm = TRUE),
      xlab = NULL, ylab = NULL, zlab = NULL,
      main = NULL, sub = NULL,
      theta = 0, phi = 15, r = sqrt(3), d = 1,
      scale = TRUE, expand = 1,
      col = "white", border = NULL, ltheta = -135, lphi = 0,
      shade = NA, box = TRUE, axes = TRUE, nticks = 5,
      ticktype = "simple", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="x">x</code>, <code id="y">y</code></td>
<td>
<p>locations of grid lines at which the values in <code>z</code> are
measured.  These must be in ascending order.  By default, equally
spaced values from 0 to 1 are used.  If <code>x</code> is a <code>list</code>,
its components <code>x$x</code> and <code>x$y</code> are used for <code>x</code>
and <code>y</code>, respectively.</p>
</td></tr>
<tr><td><code id="z">z</code></td>
<td>
<p>a matrix containing the values to be plotted (<code>NA</code>s are
allowed).  Note that <code>x</code> can be used instead of <code>z</code> for
convenience.</p>
</td></tr>
<tr><td><code id="xlim">xlim</code>, <code id="ylim">ylim</code>, <code id="zlim">zlim</code></td>
<td>
<p>x-, y-  and z-limits.  These should be chosen
to cover the range of values of the surface: see &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="xlab">xlab</code>, <code id="ylab">ylab</code>, <code id="zlab">zlab</code></td>
<td>
<p>titles for the axes.  N.B. These must be
character strings; expressions are not accepted.  Numbers will be
coerced to character strings.</p>
</td></tr>
<tr><td><code id="main">main</code>, <code id="sub">sub</code></td>
<td>
<p>main and sub title, as for <code>title</code>.</p>
</td></tr>
<tr><td><code id="theta">theta</code>, <code id="phi">phi</code></td>
<td>
<p>angles defining the viewing direction.
<code>theta</code> gives the azimuthal direction and <code>phi</code>
the colatitude.</p>
</td></tr>
<tr><td><code id="r">r</code></td>
<td>
<p>the distance of the eyepoint from the centre of the plotting box.</p>
</td></tr>
<tr><td><code id="d">d</code></td>
<td>
<p>a value which can be used to vary the strength of
the perspective transformation.  Values of <code>d</code> greater
than 1 will lessen the perspective effect and values less
and 1 will exaggerate it.</p>
</td></tr>
<tr><td><code id="scale">scale</code></td>
<td>
<p>before viewing the x, y and z coordinates of the
points defining the surface are transformed to the interval
[0,1].  If <code>scale</code> is <code>TRUE</code> the x, y and z coordinates
are transformed separately.  If <code>scale</code> is <code>FALSE</code>
the coordinates are scaled so that aspect ratios are retained.
This is useful for rendering things like DEM information.</p>
</td></tr>
<tr><td><code id="expand">expand</code></td>
<td>
<p>a expansion factor applied to the <code>z</code>
coordinates. Often used with <code>0 &lt; expand &lt; 1</code> to shrink the
plotting box in the <code>z</code> direction.</p>
</td></tr>
<tr><td><code id="col">col</code></td>
<td>
<p>the color(s) of the surface facets.  Transparent colours are
ignored.  This is recycled to the <code class="reqn">(nx-1)(ny-1)</code> facets.</p>
</td></tr>
<tr><td><code id="border">border</code></td>
<td>
<p>the color of the line drawn around the surface facets.
The default, <code>NULL</code>, corresponds to <code>par("fg")</code>.
A value of <code>NA</code> will disable the drawing of borders: this is
sometimes useful when the surface is shaded.</p>
</td></tr>
<tr><td><code id="ltheta">ltheta</code>, <code id="lphi">lphi</code></td>
<td>
<p>if finite values are specified for <code>ltheta</code>
and <code>lphi</code>, the surface is shaded as though it was being
illuminated from the direction specified by azimuth <code>ltheta</code>
and colatitude <code>lphi</code>.</p>
</td></tr>
<tr><td><code id="shade">shade</code></td>
<td>
<p>the shade at a surface facet is computed as
<code>((1+d)/2)^shade</code>, where <code>d</code> is the dot product of
a unit vector normal to the facet and a unit vector in the
direction of a light source.  Values of <code>shade</code> close
to one yield shading similar to a point light source model
and values close to zero produce no shading.  Values in the
range 0.5 to 0.75 provide an approximation to daylight
illumination.</p>
</td></tr>
<tr><td><code id="box">box</code></td>
<td>
<p>should the bounding box for the surface be displayed.
The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="axes">axes</code></td>
<td>
<p>should ticks and labels be added to the box.  The
default is <code>TRUE</code>.  If <code>box</code> is <code>FALSE</code> then no
ticks or labels are drawn.</p>
</td></tr>
<tr><td><code id="ticktype">ticktype</code></td>
<td>
<p>character: <code>"simple"</code> draws just an arrow
parallel to the axis to indicate direction of increase;
<code>"detailed"</code> draws normal ticks as per 2D plots.</p>
</td></tr>
<tr><td><code id="nticks">nticks</code></td>
<td>
<p>the (approximate) number of tick marks to draw on the
axes.  Has no effect if <code>ticktype</code> is <code>"simple"</code>.</p>
</td></tr>
<tr><td><code id="...">...</code></td>
<td>
<p>additional graphical parameters (see <code>par</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The plots are produced by first transforming the (x,y,z)
coordinates to the interval [0,1] using the limits supplied or
computed from the range of the data.  The surface is then viewed
by looking at the origin from a direction defined by <code>theta</code>
and <code>phi</code>.  If <code>theta</code> and <code>phi</code> are both zero
the viewing direction is directly down the negative y axis.
Changing <code>theta</code> will vary the azimuth and changing <code>phi</code>
the colatitude.
</p>
<p>There is a hook called <code>"persp"</code> (see <code>setHook</code>)
called after the plot is completed, which is used in the
testing code to annotate the plot page.  The hook function(s) are
called with no argument.
</p>
<p>Notice that <code>persp</code> interprets the <code>z</code> matrix as a table of
<code>f(x[i], y[j])</code> values, so that the x axis corresponds to row
number and the y axis to column number, with column 1 at the bottom,
so that with the standard rotation angles, the top left corner of the
matrix is displayed at the left hand side, closest to the user.
</p>
<p>The sizes and fonts of the axis labels and the annotations for
<code>ticktype = "detailed"</code> are controlled by graphics parameters
<code>"cex.lab"</code>/<code>"font.lab"</code> and
<code>"cex.axis"</code>/<code>"font.axis"</code> respectively.
</p>
<p>The bounding box is drawn with edges of faces facing away from the
viewer (and hence at the back of the box) with solid lines and other
edges dashed and on top of the surface.  This (and the plotting of the
axes) assumes that the axis limits are chosen so that the surface
is within the box, and the function will warn if this is not the case.
</p>


<h3>Value</h3>

<p><code>persp()</code> returns the <em>viewing transformation matrix</em>, say
<code>VT</code>, a <code class="reqn">4 \times 4</code> matrix suitable for projecting 3D
coordinates <code class="reqn">(x,y,z)</code> into the 2D plane using homogeneous 4D
coordinates <code class="reqn">(x,y,z,t)</code>.  It can be used to superimpose
additional graphical elements on the 3D plot, by
<code>lines()</code> or <code>points()</code>, using the
function <code>trans3d()</code>.
</p>


<h3>References</h3>

<p>Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988)
<em>The New S Language</em>.
Wadsworth &amp; Brooks/Cole.
</p>


<h3>See Also</h3>

<p><code>contour</code> and <code>image</code>; <code>trans3d</code>.
</p>
<p>Rotatable 3D plots can be produced by package <a href="https://CRAN.R-project.org/package=rgl"><span class="pkg">rgl</span></a>: other
ways to produce static perspective plots are available in packages
<a href="https://CRAN.R-project.org/package=lattice"><span class="pkg">lattice</span></a> and <a href="https://CRAN.R-project.org/package=scatterplot3d"><span class="pkg">scatterplot3d</span></a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(grDevices) # for trans3d
## More examples in  demo(persp) !!
##                   -----------

# (1) The Obligatory Mathematical surface.
#     Rotated sinc function.

x &lt;- seq(-10, 10, length.out = 30)
y &lt;- x
f &lt;- function(x, y) { r &lt;- sqrt(x^2+y^2); 10 * sin(r)/r }
z &lt;- outer(x, y, f)
z[is.na(z)] &lt;- 1
op &lt;- par(bg = "white")
persp(x, y, z, theta = 30, phi = 30, expand = 0.5, col = "lightblue")
persp(x, y, z, theta = 30, phi = 30, expand = 0.5, col = "lightblue",
      ltheta = 120, shade = 0.75, ticktype = "detailed",
      xlab = "X", ylab = "Y", zlab = "Sinc( r )"
) -&gt; res
round(res, 3)

# (2) Add to existing persp plot - using trans3d() :

xE &lt;- c(-10,10); xy &lt;- expand.grid(xE, xE)
points(trans3d(xy[,1], xy[,2], 6, pmat = res), col = 2, pch = 16)
lines (trans3d(x, y = 10, z = 6 + sin(x), pmat = res), col = 3)

phi &lt;- seq(0, 2*pi, length.out = 201)
r1 &lt;- 7.725 # radius of 2nd maximum
xr &lt;- r1 * cos(phi)
yr &lt;- r1 * sin(phi)
lines(trans3d(xr,yr, f(xr,yr), res), col = "pink", lwd = 2)
## (no hidden lines)

# (3) Visualizing a simple DEM model

z &lt;- 2 * volcano        # Exaggerate the relief
x &lt;- 10 * (1:nrow(z))   # 10 meter spacing (S to N)
y &lt;- 10 * (1:ncol(z))   # 10 meter spacing (E to W)
## Don't draw the grid lines :  border = NA
par(bg = "slategray")
persp(x, y, z, theta = 135, phi = 30, col = "green3", scale = FALSE,
      ltheta = -120, shade = 0.75, border = NA, box = FALSE)

# (4) Surface colours corresponding to z-values

par(bg = "white")
x &lt;- seq(-1.95, 1.95, length.out = 30)
y &lt;- seq(-1.95, 1.95, length.out = 35)
z &lt;- outer(x, y, function(a, b) a*b^2)
nrz &lt;- nrow(z)
ncz &lt;- ncol(z)
# Create a function interpolating colors in the range of specified colors
jet.colors &lt;- colorRampPalette( c("blue", "green") )
# Generate the desired number of colors from this palette
nbcol &lt;- 100
color &lt;- jet.colors(nbcol)
# Compute the z-value at the facet centres
zfacet &lt;- z[-1, -1] + z[-1, -ncz] + z[-nrz, -1] + z[-nrz, -ncz]
# Recode facet z-values into color indices
facetcol &lt;- cut(zfacet, nbcol)
persp(x, y, z, col = color[facetcol], phi = 30, theta = -30)

par(op)
</code></pre>

<hr /><div style="text-align: center;">[<a href='/r-help/4.1.3/00index.html'>Package <em>graphics</em> version 4.1.3</a> ]</div></main>

</div>
</body></html>
