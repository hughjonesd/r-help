<!DOCTYPE html><html><head><title>R: Foreign Function Interface</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body> <div style='padding: 20pt; border: 2px solid black; text-align:center;'><b>This help topic is for R version 3.0.1. For the current version of R, try <a href='https://stat.ethz.ch/R-manual/R-patched/library/base/html/Foreign.html'>https://stat.ethz.ch/R-manual/R-patched/library/base/html/Foreign.html</a></b></div><div class="container"><main>

<table style="width: 100%;"><tr><td>Foreign {base}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Foreign Function Interface</h2>

<h3>Description</h3>

<p>Functions to make calls to compiled code that has been loaded into <span class="rlang"><b>R</b></span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>       .C(.NAME, ..., NAOK = FALSE, DUP = TRUE, PACKAGE, ENCODING)
 .Fortran(.NAME, ..., NAOK = FALSE, DUP = TRUE, PACKAGE, ENCODING)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".NAME">.NAME</code></td>
<td>
<p>a character string giving the name of a C function or
Fortran subroutine, or an object of class
<code>"NativeSymbolInfo"</code>, <code>"RegisteredNativeSymbol"</code>
or <code>"NativeSymbol"</code> referring to such a name.</p>
</td></tr>
<tr><td><code id="...">...</code></td>
<td>
<p>arguments to be passed to the foreign function.  Up to 65.</p>
</td></tr>
<tr><td><code id="NAOK">NAOK</code></td>
<td>
<p>if <code>TRUE</code> then any <code>NA</code> or
<code>NaN</code> or <code>Inf</code> values in the arguments are
passed on to the foreign function.  If <code>FALSE</code>, the presence of
<code>NA</code> or <code>NaN</code> or <code>Inf</code> values is regarded as an error.</p>
</td></tr>
<tr><td><code id="DUP">DUP</code></td>
<td>
<p>if <code>TRUE</code> then arguments are duplicated before
their address is passed to C or Fortran.</p>
</td></tr>
<tr><td><code id="PACKAGE">PACKAGE</code></td>
<td>
<p>if supplied, confine the search for a character string
<code>.NAME</code> to the DLL given by this argument (plus the
conventional extension, &lsquo;<span class="file">.so</span>&rsquo;, &lsquo;<span class="file">.dll</span>&rsquo;, ...).
</p>
<p>This is intended to add safety for packages, which can ensure by
using this argument that no other package can override their external
symbols, and also speeds up the search (see &lsquo;Note&rsquo;).</p>
</td></tr>
<tr><td><code id="ENCODING">ENCODING</code></td>
<td>
<p>For back-compatibility, accepted but ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions can be used to make calls to compiled C and Fortran 77
code.  Later interfaces are <code>.Call</code> and
<code>.External</code> which are more flexible and have better
performance.
</p>
<p>These functions are both primitive, and <code>.NAME</code> is always
matched to the first argument supplied (which should not be named).
The other named arguments follow <code>...</code> and so cannot be
abbreviated.  For clarity, should avoid using names in the arguments
passed to <code>...</code> that match or partially match <code>.NAME</code>.
</p>


<h3>Value</h3>

<p>A list similar to the <code>...</code> list of arguments passed in
(including any names given to the arguments), but reflecting any
changes made by the C or Fortran code.
</p>


<h3>Argument types</h3>

<p>The mapping of the types of <span class="rlang"><b>R</b></span> arguments to C or Fortran arguments is
</p>

<table>
<tr>
 <td style="text-align: left;">
    <span class="rlang"><b>R</b></span> </td><td style="text-align: left;">     C </td><td style="text-align: left;">     Fortran</td>
</tr>
<tr>
 <td style="text-align: left;">
    integer </td><td style="text-align: left;"> int * </td><td style="text-align: left;"> integer</td>
</tr>
<tr>
 <td style="text-align: left;">
    numeric </td><td style="text-align: left;"> double * </td><td style="text-align: left;"> double precision</td>
</tr>
<tr>
 <td style="text-align: left;">
    -- or -- </td><td style="text-align: left;"> float * </td><td style="text-align: left;"> real</td>
</tr>
<tr>
 <td style="text-align: left;">
    complex </td><td style="text-align: left;"> Rcomplex * </td><td style="text-align: left;"> double complex</td>
</tr>
<tr>
 <td style="text-align: left;">
    logical </td><td style="text-align: left;"> int * </td><td style="text-align: left;"> integer </td>
</tr>
<tr>
 <td style="text-align: left;">
    character </td><td style="text-align: left;"> char ** </td><td style="text-align: left;"> [see below]</td>
</tr>
<tr>
 <td style="text-align: left;">
    raw </td><td style="text-align: left;"> unsigned char * </td><td style="text-align: left;"> not allowed</td>
</tr>
<tr>
 <td style="text-align: left;">
    list </td><td style="text-align: left;"> SEXP *</td><td style="text-align: left;"> not allowed</td>
</tr>
<tr>
 <td style="text-align: left;">
    other </td><td style="text-align: left;"> SEXP</td><td style="text-align: left;"> not allowed</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

<p>Numeric vectors in <span class="rlang"><b>R</b></span> will be passed as type <code>double *</code> to C
(and as <code>double precision</code> to Fortran) unless the argument has
attribute <code>Csingle</code> set to <code>TRUE</code> (use
<code>as.single</code> or <code>single</code>).  This mechanism is
only intended to be used to facilitate the interfacing of existing C
and Fortran code.
</p>
<p>The C type <code>Rcomplex</code> is defined in &lsquo;<span class="file">Complex.h</span>&rsquo; as a
<code>typedef struct {double r; double i;}</code>.  It may or may not be
equivalent to the C99 <code>double complex</code> type, depending on the
compiler used.
</p>
<p>Logical values are sent as <code>0</code> (<code>FALSE</code>), <code>1</code>
(<code>TRUE</code>) or <code>INT_MIN = -2147483648</code> (<code>NA</code>, but only if
<code>NAOK = TRUE</code>), and the compiled code should return one of these
three values: however non-zero values other than <code>INT_MIN</code> are
mapped to <code>TRUE</code>.
</p>
<p><em>Note:</em> The C types corresponding to <code>integer</code> and
<code>logical</code> are <code>int</code>, not <code>long</code> as in S.  This
difference matters on most 64-bit platforms, where <code>int</code> is
32-bit and <code>long</code> is 64-bit (but not on 64-bit Windows).
</p>
<p><em>Note:</em> The Fortran type corresponding to <code>logical</code> is
<code>integer</code>, not <code>logical</code>: the difference matters on some
Fortran compilers.
</p>
<p>Missing (<code>NA</code>) string values are passed to <code>.C</code> as the string
&quot;NA&quot;. As the C <code>char</code> type can represent all possible bit patterns
there appears to be no way to distinguish missing strings from the
string <code>"NA"</code>.  If this distinction is important use <code>.Call</code>.
</p>
<p><code>.Fortran</code> passes the first (only) character string of a character
vector is passed as a C character array to Fortran: that may be usable
as <code>character*255</code> if its true length is passed separately.  Only
up to 255 characters of the string are passed back.  (How well this
works, and even if it works at all, depends on the C and Fortran
compilers and the platform.)
</p>
<p>Lists, functions are other <span class="rlang"><b>R</b></span> objects can (for historical reasons) be
passed to <code>.C</code>, but the <code>.Call</code> interface is much
preferred.  All inputs apart from atomic vectors should be regarded as
read-only, and all apart from vectors (including lists), functions and
environments are now deprecated.
</p>


<h3>Warning</h3>

<p><em><code>DUP = FALSE</code> is dangerous.</em>
</p>
<p>People concerned about memory usage are strongly recommended to use
the <code>.Call</code> interface instead of these interfaces.
</p>
<p>If you pass a local variable to <code>.C</code>/<code>.Fortran</code> with
<code>DUP = FALSE</code>, your compiled code can alter the local variable and
not just the copy in the return list.  Worse, if you pass a local
variable that is a formal parameter of the calling function, you may
be able to change not only the local variable but the variable one
level up.  This will be very hard to trace.
</p>
<p>With <code>DUP = FALSE</code>, character vectors cannot be used, and single
precision values will not be returned.
</p>
<p>It is safe and useful to set <code>DUP = FALSE</code> if you do not change any
of the variables that might be affected, e.g.,
</p>
<p><code>.C("Cfunction", input = x, output = numeric(10))</code>.
</p>
<p>In this case the <code>output</code> variable did not exist before the call
so it cannot cause trouble (but as from <span class="rlang"><b>R</b></span> 2.15.1 it is not copied
even with <code>DUP = TRUE</code>).  If the <code>input</code> variable is not
changed in the C code of <code>Cfunction</code> you are safe.
</p>


<h3>Fortran symbol names</h3>

<p>All Fortran compilers known to be usable to compile <span class="rlang"><b>R</b></span> map symbol names
to lower case, and so does <code>.Fortran</code>.
</p>
<p>Symbol names containing underscores are not valid Fortran 77 (although
they are valid in Fortran 9x).  Many Fortran 77 compilers will allow
them but may translate them in a different way to names not containing
underscores.  Such names will often work with <code>.Fortran</code> (since
how they are translated is detected when <span class="rlang"><b>R</b></span> is built and the
information used by <code>.Fortran</code>), but portable code should not use
Fortran names containing underscores.
</p>
<p>Use <code>.Fortran</code> with care for compiled Fortran 9x code: it may not
work if the Fortran 9x compiler used differs from the Fortran 77 compiler
used when configuring <span class="rlang"><b>R</b></span>, especially if the subroutine name is not
lower-case or includes an underscore.  It is also possible to use
<code>.C</code> and do any necessary symbol-name translation yourself.
</p>


<h3>Copying of arguments</h3>

<p>If <code>DUP = TRUE</code> there are up to two copies made of each argument
in <code>...</code>.
</p>
<p>Prior to <span class="rlang"><b>R</b></span> 2.15.1 there were always two for vectors (one before
calling the compiled code and one to collect the results), and this is
still the case for character vectors.  For other atomic vectors, the
argument is not copied before calling the compiled code if it is not
otherwise used in the calling code (such as <code>output</code> in the
example above).  Non-atomic-vector objects are read-only to the C code
and are never copied.
</p>
<p>This behaviour can be changed by setting
<code>options(CBoundsCheck = TRUE)</code>.  In that case raw,
logical, integer, double and complex vector arguments are copied both
before and after calling the compiled code.  The first copy made is
extended at each end by guard bytes, and on return it is checked that
these are unaltered.  For <code>.C</code>, each element of a character
vector uses guard bytes.
</p>


<h3>Note</h3>

<p>If one of these functions is to be used frequently, do specify
<code>PACKAGE</code> (to confine the search to a single DLL) or pass
<code>.NAME</code> as one of the native symbol objects.  Searching for
symbols can take a long time, especially when many namespaces are loaded.
</p>
<p>You may see <code>PACKAGE = "base"</code> for symbols linked into <span class="rlang"><b>R</b></span>.  Do
not use this in your own code: such symbols are not part of the API
and may be changed without warning.
</p>
<p><code>PACKAGE = ""</code> used to be accepted (but was undocumented): it is
now an error.
</p>
<p>The way pairlists were passed by <code>.C</code> prior to <span class="rlang"><b>R</b></span> 2.15.0
was not as documented.  This has been corrected, but the
<code>.Call</code> and <code>.External</code> interfaces are much
preferred for passing anything other than atomic vectors.
</p>


<h3>References</h3>

<p>Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988)
<em>The New S Language</em>.
Wadsworth &amp; Brooks/Cole.
</p>


<h3>See Also</h3>

<p><code>dyn.load</code>, <code>.Call</code>.
</p>
<p>The &lsquo;Writing R Extensions&rsquo; manual.
</p>

<hr /><div style="text-align: center;">[<a href='/r-help/3.0.1/00index.html'>Package <em>base</em> version 3.0.1</a> ]</div></main>

</div>
</body></html>
